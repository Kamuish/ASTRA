{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ASTRA","text":"<p>This is the documentation of Astrophysical Spectral Tools for Retrieval &amp; Analysis (ASTRA), with a standard implementation of:</p> <ul> <li>Access to stellar spectra from multiple state-of-the-art spectrographs</li> <li>Construction of telluric masks, based on the observations with the worst atmospheric conditions</li> <li>Construction of high-SNR stellar templates from the available observations</li> </ul> <p>ASTRA is now working as the low-level data-interface of the s-BART pipeline for RV extraction and it also allows for:</p> <ul> <li>Built-in normalization of stellar spectra</li> <li>Built-in interpolation of stellar spectra to new wavelength grids</li> <li>Smoothing of stellar spectra</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Installation of ASTRA can be made either through Pypi or through github:</p> Pypigithub <pre><code>pip install ASTRA-spectra\n</code></pre> <pre><code>git clone git@github.com:Kamuish/ASTRA.git\ncd ASTRA\npip install . \n</code></pre> <p>By default, ASTRA does not install Telfit as it will only be needed for the masking of the telluric features. If this is the goal, it must be installed manually.</p>"},{"location":"#issues-and-contribution","title":"Issues and contribution","text":"<p>Management of any issues to the code, as well as external contribution is done through the github repository</p>"},{"location":"#changelog","title":"Changelog","text":""},{"location":"#v100-5th-of-may-2025","title":"V1.0.0 (5th of May 2025)","text":"<ul> <li>Original commit, as transposed from sBART internals</li> <li>Addition of CARMENES and MAROON-X as valid instruments for analysis</li> </ul>"},{"location":"advanced/spectra_interpolation/","title":"Interpolation of stellar spectra and templates","text":"In\u00a0[11]: Copied! <pre>from ASTRA.Components.Modelling import Spectral_Modelling\n\nSpectral_Modelling.config_help()\n</pre> from ASTRA.Components.Modelling import Spectral_Modelling  Spectral_Modelling.config_help() <pre>Configurations:\n\nName:: SAVE_DISK_SPACE\n\tDescription:: Save disk space in the outputs if different than None\n\tMandatory:: False\n\tDefault value:: DISK_SAVE_MODE.DISABLED\n\tConstraints:: Value from list &lt;&lt;enum 'DISK_SAVE_MODE'&gt;&gt;\n \nName:: WORKING_MODE\n\tDescription:: How to store the output files. If one-shot, overwrites all files, otherwise updates products\n\tMandatory:: False\n\tDefault value:: WORKING_MODE.ONE_SHOT\n\tConstraints:: Value from list &lt;&lt;enum 'WORKING_MODE'&gt;&gt;\n \nName:: INTERPOL_MODE\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: SPECTRA_INTERPOL_MODE.SPLINES\n\tConstraints:: Value from list &lt;&lt;enum 'SPECTRA_INTERPOL_MODE'&gt;&gt;\n \nName:: SPLINE_TYPE\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: SPLINE_INTERPOL_MODE.CUBIC_SPLINE\n\tConstraints:: Value from list &lt;&lt;enum 'SPLINE_INTERPOL_MODE'&gt;&gt;\n \nName:: INTERPOLATION_ERR_PROP\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: INTERPOLATION_ERR_PROP.interpolation\n\tConstraints:: Value from list &lt;&lt;enum 'INTERPOLATION_ERR_PROP'&gt;&gt;\n \nName:: NUMBER_WORKERS\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: 1\n\tConstraints:: Value inside interval &lt;(0, inf)&gt;; Edges: True\n \nName:: FLUX_SMOOTH_CONFIGS\n\tDescription:: Configure a possible flux smoothing before template construction\n\tMandatory:: False\n\tDefault value:: FLUX_SMOOTH_CONFIGS.NONE\n\tConstraints:: Value from list &lt;&lt;enum 'FLUX_SMOOTH_CONFIGS'&gt;&gt;\n \nName:: FLUX_SMOOTH_WINDOW_SIZE\n\tDescription:: Number of points that will be used for the filter to smooth the spectra\n\tMandatory:: False\n\tDefault value:: 15\n\tConstraints:: Value inside interval &lt;(0, inf)&gt;; Edges: True\n \nName:: FLUX_SMOOTH_DEG\n\tDescription:: Degree of the polynomial that will be used for the filter to smooth the spectra\n\tMandatory:: False\n\tDefault value:: 2\n\tConstraints:: Value inside interval &lt;(0, inf)&gt;; Edges: True\n \nName:: FLUX_SMOOTH_ORDER\n\tDescription:: Order in which we smooth the flux (before, after or both)\n\tMandatory:: False\n\tDefault value:: FLUX_SMOOTH_ORDER.AFTER\n\tConstraints:: Value from list &lt;&lt;enum 'FLUX_SMOOTH_ORDER'&gt;&gt;\n \n\n</pre> <p>This parent class unlocks a common API for the interpolation of spectra (either in the form of a single observation or in the form of a stellar template).</p> <p>This interface will run a serial set of operations:</p> <ul> <li>If configured to do so, smooth the stellar spectra before the interpolation</li> <li>Apply/remove a given RV shift to the wavelengths</li> <li>Interpolate the spectra and compute new flux uncertainties (based on configuration)</li> <li>If configured to do so, smooth the stellar spectra after the interpolation</li> </ul> <p>This function does not compute the limits of interpolation (i.e., it will extrapolate if the new_wavelengths are outside the valid ranges of the underlying data)</p> In\u00a0[19]: Copied! <pre>import matplotlib.pyplot as plt\n\nfrom ASTRA.Instruments import ESPRESSO\nfrom ASTRA.utils import choices\n\nframe = ESPRESSO(file_path=\"/home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\",\n                 user_configs={\"INTERPOL_MODE\": choices.SPECTRA_INTERPOL_MODE.SPLINES,\n                               \"SPLINE_INTERPOL_MODE\": choices.SPLINE_INTERPOL_MODE.CUBIC_SPLINE\n                               }\n                 )\nframe.generate_root_path(\"tmp\")\n\nspectral_order = 50 \nwave, flux, err, mask = frame.get_data_from_spectral_order(order=spectral_order)\n\nfig, axis = plt.subplots()\naxis.scatter(wave[~mask], flux[~mask], color=\"black\")\n\nwaves_to_interpol = wave[~mask][1000:1500]\nfor spline_mode in [choices.SPLINE_INTERPOL_MODE.CUBIC_SPLINE, choices.SPLINE_INTERPOL_MODE.QUADRATIC_SPLINE]:\n    new_flux, new_err = frame.interpolate_spectrum_to_wavelength(order = 50,\n                                            new_wavelengths=waves_to_interpol,\n                                            shift_RV_by=10,\n                                            RV_shift_mode=\"apply\",)\n    \n    axis.scatter(waves_to_interpol, new_flux, label=spline_mode.name, s=6)\naxis.legend(ncol=3, loc=4, bbox_to_anchor=(1,1))\naxis.set_xlim([waves_to_interpol[0], waves_to_interpol[-1]])\n</pre> import matplotlib.pyplot as plt  from ASTRA.Instruments import ESPRESSO from ASTRA.utils import choices  frame = ESPRESSO(file_path=\"/home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\",                  user_configs={\"INTERPOL_MODE\": choices.SPECTRA_INTERPOL_MODE.SPLINES,                                \"SPLINE_INTERPOL_MODE\": choices.SPLINE_INTERPOL_MODE.CUBIC_SPLINE                                }                  ) frame.generate_root_path(\"tmp\")  spectral_order = 50  wave, flux, err, mask = frame.get_data_from_spectral_order(order=spectral_order)  fig, axis = plt.subplots() axis.scatter(wave[~mask], flux[~mask], color=\"black\")  waves_to_interpol = wave[~mask][1000:1500] for spline_mode in [choices.SPLINE_INTERPOL_MODE.CUBIC_SPLINE, choices.SPLINE_INTERPOL_MODE.QUADRATIC_SPLINE]:     new_flux, new_err = frame.interpolate_spectrum_to_wavelength(order = 50,                                             new_wavelengths=waves_to_interpol,                                             shift_RV_by=10,                                             RV_shift_mode=\"apply\",)          axis.scatter(waves_to_interpol, new_flux, label=spline_mode.name, s=6) axis.legend(ncol=3, loc=4, bbox_to_anchor=(1,1)) axis.set_xlim([waves_to_interpol[0], waves_to_interpol[-1]]) <pre>2025-04-14 22:44:47.206 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-14 22:44:47.208 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 22:44:47.224 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-14 22:44:47.227 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame None rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-14 22:44:47.229 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:861 - Opening the S2D arrays from r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-14 22:44:47.248 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-14 22:44:47.319 | DEBUG    | ASTRA.base_models.Frame:build_mask:627 - Cleaning wavelength regions from []\n2025-04-14 22:44:47.320 | DEBUG    | ASTRA.base_models.Frame:build_mask:645 - Removed 0 regions ()\n2025-04-14 22:44:47.321 | DEBUG    | ASTRA.base_models.Frame:build_mask:671 - Ensuring that we have increasing wavelengths\n2025-04-14 22:44:47.333 | DEBUG    | ASTRA.base_models.Frame:build_mask:677 - Took 0 seconds ()\n2025-04-14 22:44:47.335 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-14 22:44:47.359 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:723 - Frame None rejected 37 orders due for having less than 0.25 valid pixels: 0-36\n2025-04-14 22:44:47.361 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame None rejected 37 orders for having SNR smaller than 5: 0-36\n</pre> Out[19]: <pre>(4486.688103074458, 4490.840682985041)</pre>"},{"location":"advanced/spectra_interpolation/#interpolation-of-stellar-spectra-and-templates","title":"Interpolation of stellar spectra and templates\u00b6","text":"<p>Within ASTRA, the individual Frame's and the Stellar templates have a common parent class:</p> <pre>from ASTRA.Components.Modelling import Spectral_Modelling\n</pre> <p>Due to the nature of ASTRA internals, the configurations from this parent class are not see through the config_help function when called on either of those two objects.</p>"},{"location":"advanced/spectra_normalization/","title":"Normalization of stellar spectra","text":"In\u00a0[1]: Copied! <pre>from ASTRA.Components.Spectral_Normalization import Spectral_Normalization\n\nSpectral_Normalization.config_help()\n</pre> from ASTRA.Components.Spectral_Normalization import Spectral_Normalization  Spectral_Normalization.config_help() <pre>Configurations:\n\nName:: SAVE_DISK_SPACE\n\tDescription:: Save disk space in the outputs if different than None\n\tMandatory:: False\n\tDefault value:: DISK_SAVE_MODE.DISABLED\n\tConstraints:: Value from list &lt;&lt;enum 'DISK_SAVE_MODE'&gt;&gt;\n \nName:: WORKING_MODE\n\tDescription:: How to store the output files. If one-shot, overwrites all files, otherwise updates products\n\tMandatory:: False\n\tDefault value:: WORKING_MODE.ONE_SHOT\n\tConstraints:: Value from list &lt;&lt;enum 'WORKING_MODE'&gt;&gt;\n \nName:: NORMALIZE_SPECTRA\n\tDescription:: If True, enable the normalization interfaceIf False, a call to normalize_spectra does nothing\n\tMandatory:: False\n\tDefault value:: False\n\tConstraints:: Value from dtype &lt;(&lt;class 'bool'&gt;,)&gt;\n \nName:: NORMALIZATION_MODE\n\tDescription:: Normalization method to use, as defined in the enum provided in ASTRA.utils.choices\n\tMandatory:: False\n\tDefault value:: NORMALIZATION_SOURCES.SNT\n\tConstraints:: Value from list &lt;&lt;enum 'NORMALIZATION_SOURCES'&gt;&gt;\n \nName:: S1D_folder\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: \n\tConstraints:: Value from dtype &lt;(&lt;class 'str'&gt;, &lt;class 'pathlib.Path'&gt;)&gt; and The path must exist\n \nName:: RASSINE_path\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: \n\tConstraints:: Value from dtype &lt;(&lt;class 'str'&gt;, &lt;class 'pathlib.Path'&gt;)&gt; and The path must exist\n \n\n</pre> In\u00a0[12]: Copied! <pre>import matplotlib.pyplot as plt\n\nfrom ASTRA.Instruments import ESPRESSO\nfrom ASTRA.utils import choices\n\nframe = ESPRESSO(file_path=\"/home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\",\n                 user_configs={\n                               \"NORMALIZE_SPECTRA\": True,\n                               \"NORMALIZATION_MODE\": choices.NORMALIZATION_SOURCES.POLY_FIT\n                               }\n                 )\n\nframe.generate_root_path(\"tmp\")\n\nspectral_order = 50 \nwave, flux, err, mask = frame.get_data_from_spectral_order(order=spectral_order)\n\nfig, axis = plt.subplots(nrows=2, sharex=True)\naxis[0].scatter(wave[~mask], flux[~mask], color=\"black\")\n\nwaves_to_interpol = wave[~mask][1000:1500]\nframe.normalize_spectra()\nwave, flux, err, mask = frame.get_data_from_spectral_order(order=spectral_order)\n\naxis[1].scatter(wave, flux, s=6)\naxis[0].legend(ncol=3, loc=4, bbox_to_anchor=(1,1))\n\nfor ax in axis:\n    \n    ax.set_xlim([waves_to_interpol[0], waves_to_interpol[-1]])\n\naxis[0].set_ylabel(\"Raw flux\")\naxis[1].set_ylabel(\"Normalized flux\")\naxis[1].set_xlabel(r\"Wavelength $[\\AA]$\")\naxis[1].set_ylim([0, 2])\nfig.tight_layout()\n</pre> import matplotlib.pyplot as plt  from ASTRA.Instruments import ESPRESSO from ASTRA.utils import choices  frame = ESPRESSO(file_path=\"/home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\",                  user_configs={                                \"NORMALIZE_SPECTRA\": True,                                \"NORMALIZATION_MODE\": choices.NORMALIZATION_SOURCES.POLY_FIT                                }                  )  frame.generate_root_path(\"tmp\")  spectral_order = 50  wave, flux, err, mask = frame.get_data_from_spectral_order(order=spectral_order)  fig, axis = plt.subplots(nrows=2, sharex=True) axis[0].scatter(wave[~mask], flux[~mask], color=\"black\")  waves_to_interpol = wave[~mask][1000:1500] frame.normalize_spectra() wave, flux, err, mask = frame.get_data_from_spectral_order(order=spectral_order)  axis[1].scatter(wave, flux, s=6) axis[0].legend(ncol=3, loc=4, bbox_to_anchor=(1,1))  for ax in axis:          ax.set_xlim([waves_to_interpol[0], waves_to_interpol[-1]])  axis[0].set_ylabel(\"Raw flux\") axis[1].set_ylabel(\"Normalized flux\") axis[1].set_xlabel(r\"Wavelength $[\\AA]$\") axis[1].set_ylim([0, 2]) fig.tight_layout() <pre>2025-04-29 13:01:51.665 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-29 13:01:51.667 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-29 13:01:51.684 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-29 13:01:51.686 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame None rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-29 13:01:51.688 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:862 - Opening the S2D arrays from r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-29 13:01:51.709 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-29 13:01:51.789 | DEBUG    | ASTRA.base_models.Frame:build_mask:628 - Cleaning wavelength regions from []\n2025-04-29 13:01:51.790 | DEBUG    | ASTRA.base_models.Frame:build_mask:646 - Removed 0 regions ()\n2025-04-29 13:01:51.791 | DEBUG    | ASTRA.base_models.Frame:build_mask:672 - Ensuring that we have increasing wavelengths\n2025-04-29 13:01:51.804 | DEBUG    | ASTRA.base_models.Frame:build_mask:678 - Took 0 seconds ()\n2025-04-29 13:01:51.805 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-29 13:01:51.831 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:724 - Frame None rejected 37 orders due for having less than 0.25 valid pixels: 0-36\n2025-04-29 13:01:51.832 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame None rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-29 13:01:51.857 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of  - StorageUnit::SpecNorm\n2025-04-29 13:01:51.858 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-29 13:01:51.859 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-29 13:01:51.859 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-29 13:01:51.860 | WARNING  | ASTRA.Components.Spectral_Normalization:initialize_normalization_interface:114 - Can't find previous normalization parameters on disk!\n2025-04-29 13:01:51.861 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of  - StorageUnit::SpecNorm\n2025-04-29 13:01:51.862 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-29 13:01:51.862 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-29 13:01:51.863 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n/tmp/ipykernel_23711/917063165.py:26: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  axis[0].legend(ncol=3, loc=4, bbox_to_anchor=(1,1))\n</pre>"},{"location":"advanced/spectra_normalization/#normalization-of-stellar-spectra","title":"Normalization of stellar spectra\u00b6","text":"<p>In the backend, ASTRA can call different tools to normalize the stellar spectra before any further processing stages.</p> <p>The current version of ASTRA supports different avenues to do this:</p> <ol> <li>SNT</li> <li>RASSINE</li> <li>First degree polynomial fit to the stellar spectra</li> </ol> <p>Note: SNT and RASSINE are configured (for now) to only work on the S1D files, whilst the polynomial fit can be applied to individual spectral orders.</p> <p>Note: The user should manually install SNT and/or RASSINE, as they do not come packaged with ASTRA!</p> <p>The normalization of stellar spectra is done through the Frame.normalize_spectra() method, that is introduced by the Spectral_Normalization interface in the Frame objects.</p> <p>Similarly to the interpolation interface, to check the possible configuration values we must access directly the interface:</p>"},{"location":"api/","title":"API","text":"<p>In here we specific the full (public) API of ASTRA</p>"},{"location":"api/Frame/","title":"Accessing stellar spectra","text":"<p>Define a base Frame object to interface with the observations.</p> <p>This ensures that ASTRA is fully agnostic to the instrument that we are using, as long as our data is properly loaded in the children classes of the Frame object.</p> <p>It will also provide a common set of names for commonly used header values.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame","title":"<code>Frame</code>","text":"<p>               Bases: <code>Spectrum</code>, <code>Spectral_Modelling</code>, <code>Spectral_Normalization</code></p> <p>Base Class for the different instruments.</p> <p>Providing a shared interface to spectral data and header information.</p> <p>This class defines a set of Keywords, consistent for all ASTRA supported Instruments, which can be accessed through the proper methods. The internal keywords are initialized to a default value, which the Frame will use if the instrument does  not provide that metric/value. Furthermore, all RV-related metrics are returned as astropy.Quantity objects (or lists of such objects). For such cases, one can use :func:<code>~ASTRAutils.units.convert_data</code> to convert data to different units and/or to floats</p> <p>The supported list of keywords, and the default initialization values is:</p> Internal KW name Default intialization BERV np.nan * kilometer_second previous_SBART_RV np.nan * kilometer_second previous_SBART_RV_ERR np.nan * kilometer_second DRS_CCF_MASK \"\" DRS_FLUX_CORRECTION_TEMPLATE \"\" DRS_RV np.nan * kilometer_second DRS_RV_ERR np.nan * kilometer_second drift np.nan * kilometer_second drift_ERR np.nan * kilometer_second relative_humidity np.nan,  # for telfi ambient_temperature np.nan [Kelvin],  # for telfi airmass np.nan orderwise_SNRs [] OBJECT None MAX_BERV np.nan * kilometer_second BJD None MJD None DRS-VERSION None MD5-CHECK None ISO-DATE None CONTRAST 0 CONTRAST_ERR 0 FWHM 0,  # Store this as km/ FWHM_ERR 0,  # Store this as km/ BIS SPAN 0,  # Store this as km/ BIS SPAN_ERR 0,  # Store this as km/ EXPTIME 0 RA None DEC None SPEC_TYPE \"None\",  # This keyword is simply loading the CCF mask.. DET_BINX None DET_BINY None seeing None MOON PHASE 0 MOON DISTANCE 0 INS MODE \"None\" INS NAME \"None\" PROG ID \"None\" DATE_NIGHT \"None\" Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>class Frame(Spectrum, Spectral_Modelling, Spectral_Normalization):\n    \"\"\"Base Class for the different instruments.\n\n    Providing a shared interface to spectral data and header information.\n\n    This class defines a set of Keywords, consistent for all ASTRA supported Instruments, which can be accessed\n    through the proper methods. The internal keywords are initialized to a default value, which the Frame will use\n    if the instrument does  not provide that metric/value. Furthermore, all RV-related metrics are returned as\n    astropy.Quantity objects (or lists of such objects). For such cases, one can use\n    :func:`~ASTRAutils.units.convert_data` to convert data to different units and/or to floats\n\n\n    The supported list of keywords, and the default initialization values is:\n\n\n    Internal KW name     |  Default intialization\n    ------------ | -------------\n        BERV| np.nan * kilometer_second\n    previous_SBART_RV| np.nan * kilometer_second\n    previous_SBART_RV_ERR| np.nan * kilometer_second\n    DRS_CCF_MASK| \"\"\n    DRS_FLUX_CORRECTION_TEMPLATE| \"\"\n    DRS_RV| np.nan * kilometer_second\n    DRS_RV_ERR| np.nan * kilometer_second\n    drift| np.nan * kilometer_second\n    drift_ERR| np.nan * kilometer_second\n    relative_humidity| np.nan,  # for telfi\n    ambient_temperature| np.nan [Kelvin],  # for telfi\n    airmass| np.nan\n    orderwise_SNRs| []\n    OBJECT| None\n    MAX_BERV| np.nan * kilometer_second\n    BJD| None\n    MJD| None\n    DRS-VERSION| None\n    MD5-CHECK| None\n    ISO-DATE| None\n    CONTRAST| 0\n    CONTRAST_ERR| 0\n    FWHM| 0,  # Store this as km/\n    FWHM_ERR| 0,  # Store this as km/\n    BIS SPAN| 0,  # Store this as km/\n    BIS SPAN_ERR| 0,  # Store this as km/\n    EXPTIME| 0\n    RA| None\n    DEC| None\n    SPEC_TYPE \"None\",  # This keyword is simply loading the CCF mask..\n    DET_BINX| None\n    DET_BINY| None\n    seeing| None\n    MOON PHASE| 0\n    MOON DISTANCE| 0\n    INS MODE| \"None\"\n    INS NAME| \"None\"\n    PROG ID| \"None\"\n    DATE_NIGHT| \"None\"\n\n    \"\"\"\n\n    _object_type = \"Frame\"\n    _name = \"\"\n\n    sub_instruments: dict[str, datetime.datetime] = {}\n    # Dict of options and default values for them. Specific for each instrument\n\n    _default_params = DefaultValues(\n        bypass_QualCheck=UserParam(False, constraint=BooleanValue),\n        open_without_BervCorr=UserParam(\n            False,\n            constraint=BooleanValue,\n            description=(\n                \"Ensure that the Frame is not BERV corrected, independently \"\n                \"of correction being applied or not in the official pipeline\"\n            ),\n        ),\n        apply_FluxCorr=UserParam(False, constraint=ValueFromIterable((False,))),\n        use_air_wavelengths=UserParam(\n            False,\n            constraint=BooleanValue,\n            description=\"Use air wavelengths, instead of the vacuum ones\",\n        ),\n        apply_FluxBalance_Norm=UserParam(False, constraint=ValueFromIterable((False,))),\n        reject_order_percentage=UserParam(0.25, constraint=ValueInInterval((0, 1), include_edges=True)),\n        # If the SNR is smaller, discard the order:\n        minimum_order_SNR=UserParam(\n            5,\n            constraint=Positive_Value_Constraint,\n            description=\"SNR threshold under which the spectral order is rejected\",\n        ),\n        MAX_ORDER_REJECTION=UserParam(\n            50,\n            constraint=ValueInInterval((0, 100)),\n            description=\"Maximum percentage of orders that a Frame can reject before being considered invalid\",\n        ),\n        bypass_ST_designation=UserParam(default_value=None, constraint=ValueFromIterable((None, \"S2D\", \"S1D\"))),\n        IS_SA_CORRECTED=UserParam(\n            False,\n            constraint=BooleanValue,\n            description=(\n                \"Indicates if the SA correction is already accounted in the BERV.\"\n                \" By default False, as the majority of instruments do not have it included in their BERV calculation\"\n            ),\n        ),\n        REJECT_NEGATIVE_FLUXES=UserParam(\n            True,\n            constraint=BooleanValue,\n            description=\"Reject any flux value that falls below zero. Default: True\",\n        ),\n        SIGMA_CLIP_FLUX_VALUES=UserParam(\n            -1,\n            constraint=NumericValue,\n            description=\"Sigma clip the flux values. Disabled if the value is -1 (the default),\"\n            \" as it is scarcely needed and we have outlier detection on the RV extraction\",\n        ),\n        USE_APPROX_BERV_CORRECTION=UserParam(\n            False,\n            constraint=BooleanValue,\n            description=\"Use the approximated BERV correction\",\n        ),\n    )\n\n    order_intervals: dict[DETECTOR_DEFINITION, list[int]] = {\n        DETECTOR_DEFINITION.WHITE_LIGHT: [],\n        DETECTOR_DEFINITION.RED_DET: [],\n        DETECTOR_DEFINITION.BLUE_DET: [],\n    }\n\n    def __init__(\n        self,\n        inst_name: str,\n        array_size: Dict[str, tuple],\n        file_path: Path,\n        frameID: int,\n        KW_map: Dict[str, str],\n        available_indicators: tuple,\n        user_configs: Optional[Dict[str, Any]] = None,\n        reject_subInstruments: Optional[Iterable[str]] = None,\n        need_external_data_load: bool = False,\n        init_log: bool = True,\n        quiet_user_params: bool = True,\n    ):\n        \"\"\"Init for all instruments.\n\n        The Frame object is initialized with the following set of Keywords:\n\n        Parameters\n        ----------\n        inst_name\n            Name of the instrument\n        array_size\n            Size of the data that will be loaded from disk. Follow the format [Number order, Number pixels]\n        file_path\n            Path to the file that is going to be opened\n        frameID\n            Numerical value that represents the frame's ID inside the :class:`~ASTRAdata_objects.DataClass.DataClass`\n        KW_map\n            Dictionary where the keys are names of internal Keywords and the values represent the keyword name on the\n            header of the .fits files\n        available_indicators\n            Names of available activity indicators for the instrument\n        user_configs\n            User configs information to be loaded in the parent class\n        reject_subInstruments\n            List of subInstruments to completely reject\n        need_external_data_load\n            True if the instrument must load data from a file that is not the one specified on the \"file_path\" argument\n        use_approximated_BERV_correction\n            If True, uses the approximated berv_factor\n        init_log\n            If True create a log entry with the filename\n        quiet_user_params\n            If True, there are no logs for the generation of the user parameters of each Frame\n\n        \"\"\"\n        user_configs: dict = {} if user_configs is None else user_configs\n        self.instrument_properties = {\n            \"name\": inst_name,\n            \"array_sizes\": array_size,\n            \"array_size\": None,\n            \"wavelength_coverage\": (),\n            \"resolution\": None,\n            \"EarthLocation\": None,\n            \"site_pressure\": None,  # pressure in hPa\n            \"is_drift_corrected\": None,  # True if the S2D files are already corrected from the drift\n        }\n\n        self.frameID = frameID\n        self._status = Status()  # BY DEFAULT IT IS A VALID ONE!\n\n        if not isinstance(file_path, (str, Path)):\n            raise custom_exceptions.InvalidConfiguration(\"Invalid path!\")\n\n        if not isinstance(file_path, Path):\n            file_path = Path(file_path)\n\n        self.file_path: Path = file_path\n        if init_log:\n            logger.info(f\"Creating frame from: {self.file_path}\")\n        self.inst_name = inst_name\n\n        self.sub_instrument = None\n\n        self.available_indicators = available_indicators\n\n        self._KW_map = KW_map\n        if \"UseMolecfit\" in user_configs:\n            self.spectral_format = \"S1D\"\n        elif \"bypass_ST_designation\" in user_configs:\n            self.spectral_format = user_configs[\"bypass_ST_designation\"]\n        else:\n            self.spectral_format = self.get_spectral_type()\n        self.instrument_properties[\"array_size\"] = self.instrument_properties[\"array_sizes\"][self.spectral_format]\n        self.array_size = self.instrument_properties[\"array_size\"]\n        super().__init__(user_configs=user_configs, quiet_user_params=quiet_user_params)\n\n        self.use_approximated_BERV_correction = self._internal_configs[\"USE_APPROX_BERV_CORRECTION\"]\n\n        # stores the information loaded from the header of the S2D files. THis dict will be the default values in case\n        # the instrument does not support them!\n        # orderwise SNRs OR values with units -&gt; should not be passed inside the KW_map!!!\n        self.observation_info = {\n            \"BERV\": np.nan * kilometer_second,\n            \"previous_SBART_RV\": np.nan * kilometer_second,\n            \"previous_SBART_RV_ERR\": np.nan * kilometer_second,\n            \"DRS_CCF_MASK\": \"\",\n            \"DRS_FLUX_CORRECTION_TEMPLATE\": \"\",\n            \"DRS_RV\": np.nan * kilometer_second,\n            \"DRS_RV_ERR\": np.nan * kilometer_second,\n            \"drift\": np.nan * kilometer_second,\n            \"drift_ERR\": np.nan * kilometer_second,\n            \"relative_humidity\": np.nan,  # for telfit\n            \"ambient_temperature\": np.nan,  # for telfit\n            \"airmass\": np.nan,\n            \"orderwise_SNRs\": [],\n            \"OBJECT\": None,\n            \"MAX_BERV\": np.nan * kilometer_second,\n            \"BJD\": None,\n            \"MJD\": None,\n            \"DRS-VERSION\": None,\n            \"MD5-CHECK\": None,\n            \"ISO-DATE\": None,\n            \"CONTRAST\": 0,\n            \"CONTRAST_ERR\": 0,\n            \"FWHM\": 0,  # Store this as km/s\n            \"FWHM_ERR\": 0,  # Store this as km/s\n            \"BIS SPAN\": 0,  # Store this as km/s\n            \"BIS SPAN_ERR\": 0,  # Store this as km/s\n            \"EXPTIME\": 0,\n            \"RA\": None,\n            \"DEC\": None,\n            \"SPEC_TYPE\": \"None\",  # This keyword is simply loading the CCF mask...\n            \"DET_BINX\": None,\n            \"DET_BINY\": None,\n            \"seeing\": None,\n            \"MOON PHASE\": 0,\n            \"MOON DISTANCE\": 0,\n            \"INS MODE\": \"None\",\n            \"INS NAME\": \"None\",\n            \"PROG ID\": \"None\",\n            \"DATE_NIGHT\": \"None\",\n        }\n\n        # Used to allow to reject a wavelength region from one order and keep any overlap that might exist on others\n        self._orderwise_wavelength_rejection: Optional[Dict[int, List]] = None\n\n        self.load_header_info()\n        # list of lists Each entry will be a pair of Reason: list&lt;[&lt;start, end&gt;]&gt; wavelenghts. When the S2D array is\n        # opened, these elements will be used to mask spectral regions\n\n        # TODO: understand why the typing error goes away when we use dict() instead of {}\n        self.wavelengths_to_remove: Dict[Flag, List[List[int]]] = {}\n\n        # Store here the wavelength limits for each order (if we want to impose them)!\n        self.wavelengths_to_keep = None\n\n        if reject_subInstruments is not None:\n            for bad_subInst in reject_subInstruments:\n                if self.is_SubInstrument(bad_subInst):\n                    self.add_to_status(MISSING_DATA(\"Rejected entire subInstrument\"))\n                    logger.warning(\"Rejecting subInstruments\")\n\n        if need_external_data_load:\n            self.add_to_status(LOADING_EXTERNAL_DATA)\n\n        self._header: Optional[fits.Header] = None\n        if \"skysub\" in self.file_path.stem:\n            self.is_skysub = True\n\n    def get_spectral_type(self) -&gt; str:\n        \"\"\"Check the filename to see if we are using an S1D or S2D file.\n\n        Raises:\n            custom_exceptions.InternalError: If it is not possible to recognize the filename\n\n        Returns:\n            str: S1D or S2D\n\n        \"\"\"\n        name_lowercase = self.file_path.stem.lower()\n        if \"s2d\" in name_lowercase or \"e2ds\" in name_lowercase:\n            return \"S2D\"\n        if \"s1d\" in name_lowercase:\n            return \"S1D\"\n        raise custom_exceptions.InternalError(f\"{self.name} can't recognize the file that it received!\")\n\n    def copy_into_S2D(self, new_S2D_size: Optional[Tuple[int, int]] = None) -&gt; Frame:\n        \"\"\"Return a new object which contains the S1D that that has been converted into a S2D.\n\n        Args:\n            new_S2D_size (Optional[Tuple[int, int]], optional): Size of the new S2D size, should be a tuple with two\n            elements: (number orders, pixel in order). If it is None, then uses the standard size of S2D files of this\n            instrument. Defaults to None.\n\n        Raises:\n            custom_exceptions.InvalidConfiguration: If it is already in S2D format\n\n        Returns:\n            Frame: new Frame\n\n        \"\"\"\n        if self.is_S2D:\n            raise custom_exceptions.InvalidConfiguration(\"Can't transform S2D file into S2D file\")\n        logger.warning(\"Creating a copy of a S1D Frame for transformation into S2D\")\n\n        og_shape = self.instrument_properties[\"array_sizes\"][\"S2D\"] if new_S2D_size is None else new_S2D_size\n\n        reconstructed_S2D = np.zeros(og_shape)\n        reconstructed_wavelengths = np.zeros(og_shape)\n        reconstructed_uncertainties = np.zeros(og_shape)\n\n        order_number = 0\n        order_size = reconstructed_wavelengths[0].size\n        to_break = False\n        wavelengths, flux, uncertainties, _ = self.get_data_from_full_spectrum()\n        wavelengths = wavelengths[0]\n        flux = flux[0]\n        uncertainties = uncertainties[0]\n\n        while not to_break:\n            start_order = order_size * order_number\n            end_order = start_order + order_size\n            if end_order &gt;= wavelengths.size:\n                to_break = True\n                end_order = wavelengths.size\n\n            slice_size = end_order - start_order\n            reconstructed_wavelengths[order_number] = np.pad(\n                wavelengths[start_order:end_order],\n                (0, order_size - slice_size),\n                constant_values=0,\n            )\n            reconstructed_S2D[order_number] = np.pad(\n                flux[start_order:end_order],\n                (0, order_size - slice_size),\n                constant_values=0,\n            )\n            reconstructed_uncertainties[order_number] = np.pad(\n                uncertainties[start_order:end_order],\n                (0, order_size - slice_size),\n                constant_values=0,\n            )\n            order_number += 1\n\n        # The \"new\" orders that don't have any information will have a flux of zero. Thus, they will be deemed to\n        # be invalid during the mask creation process (that is re-launched after this routine is done)\n\n        # Ensure that we don't lose information due to the SNR cut\n        user_configs = self._internal_configs._user_configs\n        user_configs[\"minimum_order_SNR\"] = 0\n\n        inst_properties = self.instrument_properties[\"array_sizes\"]\n        if new_S2D_size is not None:\n            inst_properties[\"S2D\"] = new_S2D_size\n\n        new_frame = Frame(\n            inst_name=self.inst_name,\n            array_size=inst_properties,\n            file_path=self.file_path,\n            frameID=self.frameID,\n            KW_map=self._KW_map,\n            available_indicators=self.available_indicators,\n            user_configs=self._internal_configs._user_configs,\n        )\n        new_frame.wavelengths = reconstructed_wavelengths\n        new_frame.spectra = reconstructed_S2D\n        new_frame.uncertainties = reconstructed_uncertainties\n        for key in [\"observation_info\", \"instrument_properties\"]:\n            setattr(new_frame, key, getattr(self, key))\n\n        new_frame._spectrum_has_data_on_memory = True  # to avoid new data loads!\n        new_frame._never_close = True  # ensure that we don't lose the transformation\n        new_frame.spectral_format = \"S2D\"\n        new_frame.instrument_properties[\"array_size\"] = new_S2D_size\n        new_frame.array_size = new_S2D_size\n        new_frame.sub_instrument = self.sub_instrument\n        new_frame.is_blaze_corrected = self.is_blaze_corrected\n        new_frame.observation_info[\"orderwise_SNRs\"] = [1 for _ in range(new_S2D_size[0])]\n        new_frame.regenerate_order_status()\n        return new_frame\n\n    def import_KW_from_outside(self, KW: str, value: Any, optional: bool) -&gt; None:\n        \"\"\"Allow to manually override header parameters (in memory) from the outside.\n\n        This can be used if an instrument has data stored in multiple files. This allows a post-setup\n        update of header values (for the keywords stored in observation_info)\n\n        Args:\n            KW (str): keyword name, as defined by the Frame interface\n            value (Any): New value\n            optional (bool): if it is optional, it can be a non-finite value\n\n        Raises:\n            FrameError: If we attempt to load a optional=False keyword that has a non-finite value\n\n        \"\"\"\n        if KW not in self.observation_info:\n            logger.critical(\n                \"Keyword &lt;{}&gt; is not supported by the Frames. Couldn't load it from the outside\",\n                KW,\n            )\n\n        if not np.isfinite(value):\n            if not optional:\n                logger.critical(\n                    \"Loaded mandatory keyword &lt;{}&gt; with a non-finite value for frame {}\",\n                    KW,\n                    self.fname,\n                )\n                raise FrameError\n            logger.critical(\n                \"Loaded keyword &lt;{}&gt; has a non-finite value for frame {}\",\n                KW,\n                self.fname,\n            )\n        self.observation_info[KW] = value\n\n    def reject_wavelength_region_from_order(self, order: int, region: list[tuple[int, int]]) -&gt; None:\n        \"\"\"Flag a wavelength region from specific order to be marked as invalid during the creation of the stellar mask.\n\n        This will not account for order overlaps.\n\n        Args:\n            order (_type_): _description_\n            region (_type_): _description_\n\n        Raises:\n            custom_exceptions.InvalidConfiguration:\n\n        \"\"\"\n        if not isinstance(region, (Iterable,)):\n            raise custom_exceptions.InvalidConfiguration(\"The rejection region must be a list of lists\")\n\n        if self._orderwise_wavelength_rejection is None:\n            self._orderwise_wavelength_rejection = {}\n        self._orderwise_wavelength_rejection[order] = region\n\n    def mark_wavelength_region(self, reason: Flag, wavelength_blocks: list[tuple[int, int]]) -&gt; None:\n        \"\"\"Add wavelength regions to be removed whenever the S2D file is opened.\n\n        When rejecting wavelengths through this function, we only have to specify wavelength intervels, allowing\n        to account for possible order overlap. When loading the Frame, we search through all orders to find any\n        occurence of this wavelength blocks.\n\n        Parameters\n        ----------\n        reason : Flag\n            Flag for the removal type\n        wavelength_blocks : list[tuple[int, int]]\n            List with lists of wavelength limits. [[lambda_0, lambda_1], [lambda_2, lambda_3]] to reject.z\\\n\n        \"\"\"\n        self.wavelengths_to_remove[reason] = wavelength_blocks\n\n    def select_wavelength_region(self, order: int, wavelength_blocks: list[tuple[int, int]]) -&gt; None:\n        \"\"\"Reject all wavelengths that are not part of the provided intervals.\n\n        Args:\n            order (int): Spectral order\n            wavelength_blocks (list[list[int]]): List of tuples, each containing wavelength of start and end\n            of each \"good\" interval\n\n        \"\"\"\n        if self.wavelengths_to_keep is None:\n            self.wavelengths_to_keep = {}\n        self.wavelengths_to_keep[order] = wavelength_blocks\n\n    def finalize_data_load(self, bad_flag: Optional[Flag] = None) -&gt; None:\n        \"\"\"Run for all Instruments, even those that do not need an external data load.\n\n        Checks if the non-fatal Flag \"LOADING_EXTERNAL_DATA\" exists in the Status.\n        If so, add the fatal Flag \"MISSING_EXTERNAL_DATA\". Otherwise, does nothing\n\n        \"\"\"\n        if self._status.has_flag(LOADING_EXTERNAL_DATA):\n            logger.critical(f\"Frame {self.name} did not load the external data that it needed!\")\n\n            self._status.delete_flag(LOADING_EXTERNAL_DATA)\n            if bad_flag is None:\n                self.add_to_status(MISSING_EXTERNAL_DATA)\n            else:\n                self.add_to_status(bad_flag)\n\n    def finalized_external_data_load(self) -&gt; None:\n        \"\"\"Mark frame after everything is loaded into memory.\n\n        The frames that need external data will have a Flag of \"LOADING_EXTERNAL_DATA\" that will translate into a\n        rejection of the Frame (if it is not removed).\n\n        This call will remove that flag from Status and sinalizes that this Frame managed to load everything that\n        it needed\n        \"\"\"\n        if not self.is_valid:\n            logger.warning(\"Finalizing external data loading for Frame that was already rejected.\")\n        else:\n            self._status.delete_flag(LOADING_EXTERNAL_DATA)\n\n    def add_to_status(self, new_flag: Flag) -&gt; None:\n        \"\"\"Add a new Flag to the Status of this Frame.\"\"\"\n        logger.debug(\"Updating Frame ({}) status to {}\", self.fname, new_flag)\n\n        super().add_to_status(new_flag=new_flag)\n\n        if not self.is_valid:\n            self.close_arrays()\n\n    def _data_access_checks(self) -&gt; None:\n        super()._data_access_checks()\n        if not self.is_open:\n            self.load_data()\n\n    @property\n    def status(self) -&gt; Status:\n        \"\"\"Return the Status of the entire Frame.\"\"\"\n        return self._status\n\n    @property\n    def is_SA_corrected(self) -&gt; bool:\n        \"\"\"Check if the frame was corrected from secular acceleration.\"\"\"\n        return self._internal_configs[\"IS_SA_CORRECTED\"]\n\n    ###################################\n    #          Cleaning data          #\n    ###################################\n\n    def build_mask(self, bypass_QualCheck: bool = False, assess_bad_orders: bool = True) -&gt; None:\n        \"\"\"Build a pixel-wise mask for rejection purposes.\n\n        Args:\n            bypass_QualCheck (bool, optional): If True, Bypass using the QUAL_DATA from the DRS. Defaults to False.\n            assess_bad_orders (bool, optional): if True, reject entire spectral orders based on the assess_bad_orders()\n                This can be used if we want to run more pixel-rejection methods before we evaluate bad orders.\n            Defaults to True.\n\n        \"\"\"\n        self.spectral_mask = Mask(initial_mask=np.zeros(self.instrument_properties[\"array_size\"], dtype=np.uint16))\n        if not bypass_QualCheck:\n            zero_indexes = np.where(self.qual_data != 0)\n            self.spectral_mask.add_indexes_to_mask(zero_indexes, QUAL_DATA)\n\n        self.spectral_mask.add_indexes_to_mask(np.where(~np.isfinite(self.spectra)), MISSING_DATA)\n        self.spectral_mask.add_indexes_to_mask(np.where(self.spectra == 0), MISSING_DATA)\n\n        if self._internal_configs[\"REJECT_NEGATIVE_FLUXES\"]:\n            self.spectral_mask.add_indexes_to_mask(np.where(self.spectra &lt; 0), MISSING_DATA)\n\n        self.spectral_mask.add_indexes_to_mask(np.where(self.uncertainties == 0), MISSING_DATA)\n        self.spectral_mask.add_indexes_to_mask(np.where(~np.isfinite(self.uncertainties)), MISSING_DATA)\n\n        order_map = {i: (np.min(self.wavelengths[i]), np.max(self.wavelengths[i])) for i in range(self.N_orders)}\n        removal_reasons = [i.name for i in self.wavelengths_to_remove.keys()]\n        N_point_removed = []\n        time_took = []\n\n        logger.debug(f\"Cleaning wavelength regions from {removal_reasons}\")\n\n        for removal_reason, wavelengths in self.wavelengths_to_remove.items():\n            start_time = time.time()\n            nrem = len(wavelengths)\n\n            N_point_removed.append(nrem)\n            for wave_pair in wavelengths:\n                for order in range(self.N_orders):\n                    if check_if_overlap(wave_pair, order_map[order]):\n                        indexes = np.where(\n                            np.logical_and(\n                                self.wavelengths[order] &gt;= wave_pair[0],\n                                self.wavelengths[order] &lt;= wave_pair[1],\n                            ),\n                        )\n                        self.spectral_mask.add_indexes_to_mask_order(order, indexes, removal_reason)\n            time_took.append(time.time() - start_time)\n        logger.debug(\n            \"Removed {} regions ({})\",\n            sum(N_point_removed),\n            \" + \".join(map(str, N_point_removed)),\n        )\n\n        if self._internal_configs[\"SIGMA_CLIP_FLUX_VALUES\"] &gt; 0:\n            logger.info(\"Sigma-clipping on flux is activated. Running rejection procedure\")\n            median_level = np.median(self.spectra, axis=1)\n            threshold = (\n                self._internal_configs[\"SIGMA_CLIP_FLUX_VALUES\"] * self.uncertainties + median_level[:, np.newaxis]\n            )\n            self.spectral_mask.add_indexes_to_mask(np.where(self.spectra &gt; threshold), MISSING_DATA)\n\n        if self._orderwise_wavelength_rejection is not None:\n            logger.info(\"Rejecting spectral chunks from individual orders\")\n            for order, region in self._orderwise_wavelength_rejection.items():\n                for subregion in region:\n                    indexes = np.where(\n                        np.logical_and(\n                            self.wavelengths[order] &gt;= subregion[0],\n                            self.wavelengths[order] &lt;= subregion[1],\n                        ),\n                    )\n                    self.spectral_mask.add_indexes_to_mask_order(order, indexes, NON_COMMON_WAVELENGTH)\n\n        logger.debug(\"Ensuring that we have increasing wavelengths\")\n\n        diffs = np.where(np.diff(self.wavelengths, axis=1) &lt; 0)\n        if diffs[0].size &gt; 0:\n            logger.warning(\"Found non-increasing wavelengths on {}\", self.name)\n            self.spectral_mask.add_indexes_to_mask(diffs, QUAL_DATA(\"Non-increasing wavelengths\"))\n        logger.debug(\"Took {} seconds ({})\", sum(time_took), \" + \".join(map(str, time_took)))\n\n        if assess_bad_orders:\n            self.assess_bad_orders()\n\n        if self.wavelengths_to_keep is not None:\n            logger.info(\"Provided desired wavelength region. Rejecting regions outside it\")\n            for order in range(self.N_orders):\n                good_regions = self.wavelengths_to_keep[order]\n                if len(good_regions) == 0:  # TODO: ensure that the order is also rejected\n                    continue\n\n                inds = np.zeros(self.wavelengths[order].size, dtype=bool)\n                for region in good_regions:\n                    wavelengths_to_keep = np.where(\n                        np.logical_and(\n                            self.wavelengths[order] &gt;= region[0],\n                            self.wavelengths[order] &lt;= region[1],\n                        ),\n                    )\n                    inds[wavelengths_to_keep] = True\n                self.spectral_mask.add_indexes_to_mask_order(order, np.where(~inds), NON_COMMON_WAVELENGTH)\n\n    def assess_bad_orders(self) -&gt; None:\n        \"\"\"Evaluate the orders and Frames that can be fully rejected.\n\n        Goals:\n        1) Check if any order rejects more than *reject_order_percentage* % of the pixels. If so, rejects it\n        2) Apply SNR cut of *minimum_order_SNR*\n        3) if a Frame rejects more than *MAX_ORDER_REJECTION * % of all orders, it is rejected from the analysis.\n\n        \"\"\"\n        # True in the points to mask\n        logger.debug(\"Rejecting spectral orders\")\n\n        if self.spectral_mask is not None:\n            entire_mask = self.spectral_mask.get_custom_mask()\n\n            for order, value in enumerate(entire_mask):\n                # See if the total amounf of rejected points is larger than\n                # 1 - reject_order-percentage of the entire order\n                perc = self._internal_configs[\"reject_order_percentage\"]\n                if np.sum(value) &gt; (1 - perc) * self.pixels_per_order:\n                    self._OrderStatus.add_flag_to_order(order, HIGH_CONTAMINATION(\"Rejection threshold met in order\"))\n\n        if len(self.bad_orders) &gt; 0:\n            logger.debug(\n                \"Frame {} rejected {} orders due for having less than {} valid pixels: {}\",\n                self.frameID,\n                len(self.bad_orders),\n                self._internal_configs[\"reject_order_percentage\"],\n                ranges(list(self.bad_orders)),\n            )\n\n        if self.is_S2D:  # we don't have the SNR for the S1D file!\n            bad_SNR = []\n            SNRS = self.get_KW_value(\"orderwise_SNRs\")\n            for order in range(self.N_orders):\n                if SNRS[order] &lt; self._internal_configs[\"minimum_order_SNR\"]:\n                    self._OrderStatus.add_flag_to_order(order, LOW_SNR(\"Minimum SNR not met in order\"))\n                    bad_SNR.append(order)\n\n            if len(bad_SNR) &gt; 0:\n                logger.info(\n                    \"Frame {} rejected {} orders for having SNR smaller than {}: {}\",\n                    self.frameID,\n                    len(bad_SNR),\n                    self._internal_configs[\"minimum_order_SNR\"],\n                    ranges(bad_SNR),\n                )\n\n        if len(self.bad_orders) &gt;= self._internal_configs[\"MAX_ORDER_REJECTION\"] * self.N_orders / 100:\n            logger.warning(\n                \"Frame {} is rejecting more than {} % of the spectral orders\",\n                self,\n                self._internal_configs[\"MAX_ORDER_REJECTION\"],\n            )\n            self.add_to_status(\n                NO_VALID_ORDERS(\n                    f\" Rejected more than {self._internal_configs['MAX_ORDER_REJECTION']} % of spectral orders\",\n                ),\n            )\n\n    ####################################\n    #      Sanity Checks               #\n    ####################################\n    def check_header_QC(self, header: fits.header.Header) -&gt; None:\n        \"\"\"Check if the header keywords are in accordance with their default value.\n\n        Each instrument should do this check on its own\n\n        This function will check for two things:\n        1. Fatal keywords - will mark the Frame as invalid\n        2. Warning Keywords - the frame is still valid, but it has a warning issued in the logs\n\n        If any of those conditions is met, make sure that the flags meet the following naming conditions\n        (so that we can filter by them later on):\n\n        For fatal flags\n        ```\n        msg = f\"QC flag {flag} has taken the bad value of {bad_value}\"\n        self.add_to_status(FATAL_KW(msg))\n        ```\n\n        For warnings:\n        ```\n        msg = f\"QC flag {flag} meets the bad value\"\n        self._status.store_warning(KW_WARNING(msg))\n        ```\n        \"\"\"\n\n    def find_instrument_type(self) -&gt; None:\n        \"\"\"Compare the date of observation with pre-defined sub-Instruments to see where it fits.\"\"\"\n        obs_date = self.get_KW_value(\"ISO-DATE\")\n        obs_date = \"-\".join(obs_date.split(\"T\")).split(\":\")[0]\n        obs_date = datetime.datetime.strptime(obs_date, r\"%Y-%m-%d-%H\")\n\n        for key, threshold in self.__class__.sub_instruments.items():\n            # If it is not higher tha  the threshold, then it beleongs in this \"interval\"\n            if not obs_date &gt; threshold:\n                self.sub_instrument = key\n                break\n        else:\n            raise custom_exceptions.InternalError(\"no sub-instrument found for observation\")\n\n    #####################################\n    #      Handle data management      #\n    ####################################\n    def get_S1D_name(self) -&gt; str:\n        \"\"\"Build the S1D name that should be associated with this Frame.\n\n        If it is already a S1D, returns the actual name.\n        If it is not, remove \"blaze\" from the filename and replaces \"S2D\" with \"S1D\"\n\n        \"\"\"\n        # TODO: this will not work for non-ESPRESSO files\n\n        if self.is_S1D:\n            return self.fname\n        name = self.fname\n        return name.replace(\"BLAZE_\", \"\").replace(\"S2D\", \"S1D\")\n\n    def load_data(self) -&gt; None:\n        \"\"\"Abstraction to load all data of this Frame.\n\n        If the Frame is already open, it does nothing.\n        Calls the S1D or S2D version of the data load, depending on file type\n        Can remove BERV correction at run time, if properly configured to do so.\n\n        Raises:\n            custom_exceptions.InternalError: If it is neither S2D or S1D\n            FrameError: If the frame is no longer valid after loading\n\n        \"\"\"\n        if self.is_open:\n            return\n\n        if self.is_S1D:\n            self.load_S1D_data()\n        elif self.is_S2D:\n            self.load_S2D_data()\n        else:\n            raise custom_exceptions.InternalError(\"something went wrong on this frame\")\n\n        if not self.is_valid:\n            raise FrameError(\"Frame is no longer valid\")\n\n        BERV_value = self.get_KW_value(\"BERV\")\n\n        if not self._internal_configs[\"open_without_BervCorr\"]:\n            self.apply_BERV_correction(BERV_value)\n        else:\n            logger.warning(f\"Opening {self.name} without the BERV correction\")\n            self.remove_BERV_correction(BERV_value)\n\n    def load_S1D_data(self) -&gt; None:\n        \"\"\"To be overriden by the children classes.\"\"\"\n        logger.debug(\"Opening the S1D arrays from {}\", self.fname)\n        if not self.is_valid:\n            raise FrameError\n        self._spectrum_has_data_on_memory = True\n\n    def load_S2D_data(self) -&gt; None:\n        \"\"\"To be overriden by the children classes.\"\"\"\n        logger.debug(\"Opening the S2D arrays from {}\", self.fname)\n        if not self.is_valid:\n            raise FrameError\n        self._spectrum_has_data_on_memory = True\n\n    def load_instrument_specific_KWs(self, header: Mapping[str, Any]) -&gt; None:\n        \"\"\"Load instrument-specific KW values that can't be loaded in a general fashion.\n\n        To be overriden by the different instruments\n\n        Args:\n            header (Mapping[str, Any]): header unit of this observation\n\n        \"\"\"\n\n    def load_header_info(self) -&gt; None:\n        \"\"\"Open the header of the fits file and load the necessary keywords.\n\n        Does the following operations:\n        1) Load header assuming fits file\n        2) Parse through the _KW_map to load header keywords\n        3) Call self.load_instrument_specific_KWs\n        4) Call check_header_QC(hdu)\n        5) Call find_instrument_type()\n        6) Call assess_bad_orders()\n\n        \"\"\"\n        try:\n            hdu = fits.getheader(self.file_path)\n        except FileNotFoundError:\n            msg = f\"File &lt;{self.file_path}&gt; does not exist\"\n            self.add_to_status(MISSING_FILE(msg))\n            logger.critical(msg)\n            return\n\n        for internal_KW, S2D_KW in self._KW_map.items():\n            self.observation_info[internal_KW] = hdu[S2D_KW]\n\n        self.load_instrument_specific_KWs(hdu)\n        self.check_header_QC(hdu)\n        self.find_instrument_type()\n        self.assess_bad_orders()\n\n    ####################################\n    #       Access data\n    ####################################\n\n    def get_KW_value(self, KW: str) -&gt; Any:\n        \"\"\"Get a given KW value that is defined in the common framework.\"\"\"\n        return self.observation_info[KW]\n\n    def get_header_value(self, kw: str) -&gt; Any:\n        \"\"\"Directly retrieves a KW from the header.\n\n        After this is called, the frame will keep the header stored in memory until the object is deleted\n\n        Args:\n            kw (str): Keyword name, present in the fits header\n\n        Returns:\n            Any: Header value\n\n        \"\"\"\n        if self._header is None:\n            self._header = fits.getheader(self.file_path)\n        return self._header[kw]\n\n    ####################################\n    #       properties of the Frames\n    ####################################\n\n    @property\n    def is_S1D(self) -&gt; bool:\n        \"\"\"Check if Frame is of S1D format.\"\"\"\n        return self.spectral_format == \"S1D\"\n\n    @property\n    def is_S2D(self) -&gt; bool:\n        \"\"\"Check if Frame is of S2D format.\"\"\"\n        return self.spectral_format == \"S2D\"\n\n    @property\n    def has_warnings(self) -&gt; bool:\n        \"\"\"Check if Frame has any warnings.\"\"\"\n        return self._status.has_warnings\n\n    def is_Instrument(self, Instrument: str) -&gt; bool:\n        \"\"\"Check if Frame is from a given instrument.\"\"\"\n        return self.inst_name == Instrument\n\n    def is_SubInstrument(self, sub_instrument: str) -&gt; bool:\n        \"\"\"Check if the current instrument is from the given time_block (e.g ESPRESSO18/ESPRESSO19).\n\n        Parameters\n        ----------\n        sub_instrument : str\n            Name of the time block that is going to be checked\n\n        Returns\n        -------\n        [bool]\n            Results from the comparison\n\n        \"\"\"\n        return self.sub_instrument == sub_instrument\n\n    @property\n    def previous_RV_measurements(self) -&gt; tuple[RV_measurement, RV_measurement]:\n        \"\"\"Get previous DRS RV and uncertainty.\"\"\"\n        return self.get_KW_value(\"DRS_RV\"), self.get_KW_value(\"DRS_RV_ERR\")\n\n    @property\n    def bare_fname(self) -&gt; str:\n        \"\"\"Returns the file name without the _S2D (and similar) parts.\n\n        The children classes must overload this property. Otherwise, returns the full filename\n        \"\"\"\n        return self.fname\n\n    @property\n    def fname(self) -&gt; str:\n        \"\"\"Get filename.\"\"\"\n        return self.file_path.name\n\n    @property\n    def min_pixel_in_order(self) -&gt; int:\n        \"\"\"Minimum number of pixels in order to be a valid one.\"\"\"\n        return self._internal_configs[\"reject_order_percentage\"] * self.pixels_per_order\n\n    @property\n    def spectrum_information(self) -&gt; dict[str, Any]:\n        \"\"\"Get general instrument and spectra information.\"\"\"\n        return {\n            \"subInstrument\": self.sub_instrument,\n            \"filename\": self.bare_fname,\n            \"is_S2D\": self.is_S2D,\n            \"is_S1D\": self.is_S1D,\n            **super().spectrum_information,\n        }\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return self.__str__()\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return (\n            f\"Frame of {self.inst_name} : {self.sub_instrument}\"\n            f\" data ({self.get_KW_value('ISO-DATE')}; ID = {self.frameID})\"\n        )\n\n    def plot_spectra(\n        self,\n        which_orders: None | DETECTOR_DEFINITION | list[int] = None,\n        axis=None,\n    ):\n        \"\"\"Plot the spectra.\n\n        Args:\n            which_orders (None | DETECTOR_DEFINITION | list[int], optional): Either a pre-configured\n            detector definition, a list of orders, or None (plots all orders). Defaults to None.\n            axis (_type_, optional): if None, create a new figure. Otherwise, use this one. Defaults to None.\n\n        \"\"\"\n        fig = None\n        if axis is None:\n            fig, axis = plt.subplots()\n        wf, ff, ef, mf = self.get_data_from_full_spectrum()\n\n        if which_orders is None:\n            which_orders = DETECTOR_DEFINITION.WHITE_LIGHT\n\n        if isinstance(which_orders, (list, tuple)):\n            orders_to_plot = which_orders\n        else:\n            orders_to_plot = self.order_intervals[which_orders]\n\n        for sl in orders_to_plot:\n            w, f, e, m = wf[sl], ff[sl], ef[sl], mf[sl]\n            axis.errorbar(w[~m], f[~m], e[~m], ls=\"\", marker=\"x\")\n\n        return fig, axis\n\n    def trigger_data_storage(self, *args, **kwargs):\n        super().trigger_data_storage(*args, **kwargs)\n        print(\"frame\")\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.bare_fname","title":"<code>bare_fname</code>  <code>property</code>","text":"<p>Returns the file name without the _S2D (and similar) parts.</p> <p>The children classes must overload this property. Otherwise, returns the full filename</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.fname","title":"<code>fname</code>  <code>property</code>","text":"<p>Get filename.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.has_warnings","title":"<code>has_warnings</code>  <code>property</code>","text":"<p>Check if Frame has any warnings.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.is_S1D","title":"<code>is_S1D</code>  <code>property</code>","text":"<p>Check if Frame is of S1D format.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.is_S2D","title":"<code>is_S2D</code>  <code>property</code>","text":"<p>Check if Frame is of S2D format.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.is_SA_corrected","title":"<code>is_SA_corrected</code>  <code>property</code>","text":"<p>Check if the frame was corrected from secular acceleration.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.min_pixel_in_order","title":"<code>min_pixel_in_order</code>  <code>property</code>","text":"<p>Minimum number of pixels in order to be a valid one.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.previous_RV_measurements","title":"<code>previous_RV_measurements</code>  <code>property</code>","text":"<p>Get previous DRS RV and uncertainty.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.spectrum_information","title":"<code>spectrum_information</code>  <code>property</code>","text":"<p>Get general instrument and spectra information.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.status","title":"<code>status</code>  <code>property</code>","text":"<p>Return the Status of the entire Frame.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.add_to_status","title":"<code>add_to_status(new_flag)</code>","text":"<p>Add a new Flag to the Status of this Frame.</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def add_to_status(self, new_flag: Flag) -&gt; None:\n    \"\"\"Add a new Flag to the Status of this Frame.\"\"\"\n    logger.debug(\"Updating Frame ({}) status to {}\", self.fname, new_flag)\n\n    super().add_to_status(new_flag=new_flag)\n\n    if not self.is_valid:\n        self.close_arrays()\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.assess_bad_orders","title":"<code>assess_bad_orders()</code>","text":"<p>Evaluate the orders and Frames that can be fully rejected.</p> <p>Goals: 1) Check if any order rejects more than reject_order_percentage % of the pixels. If so, rejects it 2) Apply SNR cut of minimum_order_SNR 3) if a Frame rejects more than *MAX_ORDER_REJECTION * % of all orders, it is rejected from the analysis.</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def assess_bad_orders(self) -&gt; None:\n    \"\"\"Evaluate the orders and Frames that can be fully rejected.\n\n    Goals:\n    1) Check if any order rejects more than *reject_order_percentage* % of the pixels. If so, rejects it\n    2) Apply SNR cut of *minimum_order_SNR*\n    3) if a Frame rejects more than *MAX_ORDER_REJECTION * % of all orders, it is rejected from the analysis.\n\n    \"\"\"\n    # True in the points to mask\n    logger.debug(\"Rejecting spectral orders\")\n\n    if self.spectral_mask is not None:\n        entire_mask = self.spectral_mask.get_custom_mask()\n\n        for order, value in enumerate(entire_mask):\n            # See if the total amounf of rejected points is larger than\n            # 1 - reject_order-percentage of the entire order\n            perc = self._internal_configs[\"reject_order_percentage\"]\n            if np.sum(value) &gt; (1 - perc) * self.pixels_per_order:\n                self._OrderStatus.add_flag_to_order(order, HIGH_CONTAMINATION(\"Rejection threshold met in order\"))\n\n    if len(self.bad_orders) &gt; 0:\n        logger.debug(\n            \"Frame {} rejected {} orders due for having less than {} valid pixels: {}\",\n            self.frameID,\n            len(self.bad_orders),\n            self._internal_configs[\"reject_order_percentage\"],\n            ranges(list(self.bad_orders)),\n        )\n\n    if self.is_S2D:  # we don't have the SNR for the S1D file!\n        bad_SNR = []\n        SNRS = self.get_KW_value(\"orderwise_SNRs\")\n        for order in range(self.N_orders):\n            if SNRS[order] &lt; self._internal_configs[\"minimum_order_SNR\"]:\n                self._OrderStatus.add_flag_to_order(order, LOW_SNR(\"Minimum SNR not met in order\"))\n                bad_SNR.append(order)\n\n        if len(bad_SNR) &gt; 0:\n            logger.info(\n                \"Frame {} rejected {} orders for having SNR smaller than {}: {}\",\n                self.frameID,\n                len(bad_SNR),\n                self._internal_configs[\"minimum_order_SNR\"],\n                ranges(bad_SNR),\n            )\n\n    if len(self.bad_orders) &gt;= self._internal_configs[\"MAX_ORDER_REJECTION\"] * self.N_orders / 100:\n        logger.warning(\n            \"Frame {} is rejecting more than {} % of the spectral orders\",\n            self,\n            self._internal_configs[\"MAX_ORDER_REJECTION\"],\n        )\n        self.add_to_status(\n            NO_VALID_ORDERS(\n                f\" Rejected more than {self._internal_configs['MAX_ORDER_REJECTION']} % of spectral orders\",\n            ),\n        )\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.build_mask","title":"<code>build_mask(bypass_QualCheck=False, assess_bad_orders=True)</code>","text":"<p>Build a pixel-wise mask for rejection purposes.</p> <p>Parameters:</p> Name Type Description Default <code>bypass_QualCheck</code> <code>bool</code> <p>If True, Bypass using the QUAL_DATA from the DRS. Defaults to False.</p> <code>False</code> <code>assess_bad_orders</code> <code>bool</code> <p>if True, reject entire spectral orders based on the assess_bad_orders() This can be used if we want to run more pixel-rejection methods before we evaluate bad orders.</p> <code>True</code> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def build_mask(self, bypass_QualCheck: bool = False, assess_bad_orders: bool = True) -&gt; None:\n    \"\"\"Build a pixel-wise mask for rejection purposes.\n\n    Args:\n        bypass_QualCheck (bool, optional): If True, Bypass using the QUAL_DATA from the DRS. Defaults to False.\n        assess_bad_orders (bool, optional): if True, reject entire spectral orders based on the assess_bad_orders()\n            This can be used if we want to run more pixel-rejection methods before we evaluate bad orders.\n        Defaults to True.\n\n    \"\"\"\n    self.spectral_mask = Mask(initial_mask=np.zeros(self.instrument_properties[\"array_size\"], dtype=np.uint16))\n    if not bypass_QualCheck:\n        zero_indexes = np.where(self.qual_data != 0)\n        self.spectral_mask.add_indexes_to_mask(zero_indexes, QUAL_DATA)\n\n    self.spectral_mask.add_indexes_to_mask(np.where(~np.isfinite(self.spectra)), MISSING_DATA)\n    self.spectral_mask.add_indexes_to_mask(np.where(self.spectra == 0), MISSING_DATA)\n\n    if self._internal_configs[\"REJECT_NEGATIVE_FLUXES\"]:\n        self.spectral_mask.add_indexes_to_mask(np.where(self.spectra &lt; 0), MISSING_DATA)\n\n    self.spectral_mask.add_indexes_to_mask(np.where(self.uncertainties == 0), MISSING_DATA)\n    self.spectral_mask.add_indexes_to_mask(np.where(~np.isfinite(self.uncertainties)), MISSING_DATA)\n\n    order_map = {i: (np.min(self.wavelengths[i]), np.max(self.wavelengths[i])) for i in range(self.N_orders)}\n    removal_reasons = [i.name for i in self.wavelengths_to_remove.keys()]\n    N_point_removed = []\n    time_took = []\n\n    logger.debug(f\"Cleaning wavelength regions from {removal_reasons}\")\n\n    for removal_reason, wavelengths in self.wavelengths_to_remove.items():\n        start_time = time.time()\n        nrem = len(wavelengths)\n\n        N_point_removed.append(nrem)\n        for wave_pair in wavelengths:\n            for order in range(self.N_orders):\n                if check_if_overlap(wave_pair, order_map[order]):\n                    indexes = np.where(\n                        np.logical_and(\n                            self.wavelengths[order] &gt;= wave_pair[0],\n                            self.wavelengths[order] &lt;= wave_pair[1],\n                        ),\n                    )\n                    self.spectral_mask.add_indexes_to_mask_order(order, indexes, removal_reason)\n        time_took.append(time.time() - start_time)\n    logger.debug(\n        \"Removed {} regions ({})\",\n        sum(N_point_removed),\n        \" + \".join(map(str, N_point_removed)),\n    )\n\n    if self._internal_configs[\"SIGMA_CLIP_FLUX_VALUES\"] &gt; 0:\n        logger.info(\"Sigma-clipping on flux is activated. Running rejection procedure\")\n        median_level = np.median(self.spectra, axis=1)\n        threshold = (\n            self._internal_configs[\"SIGMA_CLIP_FLUX_VALUES\"] * self.uncertainties + median_level[:, np.newaxis]\n        )\n        self.spectral_mask.add_indexes_to_mask(np.where(self.spectra &gt; threshold), MISSING_DATA)\n\n    if self._orderwise_wavelength_rejection is not None:\n        logger.info(\"Rejecting spectral chunks from individual orders\")\n        for order, region in self._orderwise_wavelength_rejection.items():\n            for subregion in region:\n                indexes = np.where(\n                    np.logical_and(\n                        self.wavelengths[order] &gt;= subregion[0],\n                        self.wavelengths[order] &lt;= subregion[1],\n                    ),\n                )\n                self.spectral_mask.add_indexes_to_mask_order(order, indexes, NON_COMMON_WAVELENGTH)\n\n    logger.debug(\"Ensuring that we have increasing wavelengths\")\n\n    diffs = np.where(np.diff(self.wavelengths, axis=1) &lt; 0)\n    if diffs[0].size &gt; 0:\n        logger.warning(\"Found non-increasing wavelengths on {}\", self.name)\n        self.spectral_mask.add_indexes_to_mask(diffs, QUAL_DATA(\"Non-increasing wavelengths\"))\n    logger.debug(\"Took {} seconds ({})\", sum(time_took), \" + \".join(map(str, time_took)))\n\n    if assess_bad_orders:\n        self.assess_bad_orders()\n\n    if self.wavelengths_to_keep is not None:\n        logger.info(\"Provided desired wavelength region. Rejecting regions outside it\")\n        for order in range(self.N_orders):\n            good_regions = self.wavelengths_to_keep[order]\n            if len(good_regions) == 0:  # TODO: ensure that the order is also rejected\n                continue\n\n            inds = np.zeros(self.wavelengths[order].size, dtype=bool)\n            for region in good_regions:\n                wavelengths_to_keep = np.where(\n                    np.logical_and(\n                        self.wavelengths[order] &gt;= region[0],\n                        self.wavelengths[order] &lt;= region[1],\n                    ),\n                )\n                inds[wavelengths_to_keep] = True\n            self.spectral_mask.add_indexes_to_mask_order(order, np.where(~inds), NON_COMMON_WAVELENGTH)\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.check_header_QC","title":"<code>check_header_QC(header)</code>","text":"<p>Check if the header keywords are in accordance with their default value.</p> <p>Each instrument should do this check on its own</p> <p>This function will check for two things: 1. Fatal keywords - will mark the Frame as invalid 2. Warning Keywords - the frame is still valid, but it has a warning issued in the logs</p> <p>If any of those conditions is met, make sure that the flags meet the following naming conditions (so that we can filter by them later on):</p> <p>For fatal flags <pre><code>msg = f\"QC flag {flag} has taken the bad value of {bad_value}\"\nself.add_to_status(FATAL_KW(msg))\n</code></pre></p> <p>For warnings: <pre><code>msg = f\"QC flag {flag} meets the bad value\"\nself._status.store_warning(KW_WARNING(msg))\n</code></pre></p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def check_header_QC(self, header: fits.header.Header) -&gt; None:\n    \"\"\"Check if the header keywords are in accordance with their default value.\n\n    Each instrument should do this check on its own\n\n    This function will check for two things:\n    1. Fatal keywords - will mark the Frame as invalid\n    2. Warning Keywords - the frame is still valid, but it has a warning issued in the logs\n\n    If any of those conditions is met, make sure that the flags meet the following naming conditions\n    (so that we can filter by them later on):\n\n    For fatal flags\n    ```\n    msg = f\"QC flag {flag} has taken the bad value of {bad_value}\"\n    self.add_to_status(FATAL_KW(msg))\n    ```\n\n    For warnings:\n    ```\n    msg = f\"QC flag {flag} meets the bad value\"\n    self._status.store_warning(KW_WARNING(msg))\n    ```\n    \"\"\"\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.copy_into_S2D","title":"<code>copy_into_S2D(new_S2D_size=None)</code>","text":"<p>Return a new object which contains the S1D that that has been converted into a S2D.</p> <p>Parameters:</p> Name Type Description Default <code>new_S2D_size</code> <code>Optional[Tuple[int, int]]</code> <p>Size of the new S2D size, should be a tuple with two</p> <code>None</code> <code>elements</code> <p>(number orders, pixel in order). If it is None, then uses the standard size of S2D files of this</p> required <p>Raises:</p> Type Description <code>InvalidConfiguration</code> <p>If it is already in S2D format</p> <p>Returns:</p> Name Type Description <code>Frame</code> <code>Frame</code> <p>new Frame</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def copy_into_S2D(self, new_S2D_size: Optional[Tuple[int, int]] = None) -&gt; Frame:\n    \"\"\"Return a new object which contains the S1D that that has been converted into a S2D.\n\n    Args:\n        new_S2D_size (Optional[Tuple[int, int]], optional): Size of the new S2D size, should be a tuple with two\n        elements: (number orders, pixel in order). If it is None, then uses the standard size of S2D files of this\n        instrument. Defaults to None.\n\n    Raises:\n        custom_exceptions.InvalidConfiguration: If it is already in S2D format\n\n    Returns:\n        Frame: new Frame\n\n    \"\"\"\n    if self.is_S2D:\n        raise custom_exceptions.InvalidConfiguration(\"Can't transform S2D file into S2D file\")\n    logger.warning(\"Creating a copy of a S1D Frame for transformation into S2D\")\n\n    og_shape = self.instrument_properties[\"array_sizes\"][\"S2D\"] if new_S2D_size is None else new_S2D_size\n\n    reconstructed_S2D = np.zeros(og_shape)\n    reconstructed_wavelengths = np.zeros(og_shape)\n    reconstructed_uncertainties = np.zeros(og_shape)\n\n    order_number = 0\n    order_size = reconstructed_wavelengths[0].size\n    to_break = False\n    wavelengths, flux, uncertainties, _ = self.get_data_from_full_spectrum()\n    wavelengths = wavelengths[0]\n    flux = flux[0]\n    uncertainties = uncertainties[0]\n\n    while not to_break:\n        start_order = order_size * order_number\n        end_order = start_order + order_size\n        if end_order &gt;= wavelengths.size:\n            to_break = True\n            end_order = wavelengths.size\n\n        slice_size = end_order - start_order\n        reconstructed_wavelengths[order_number] = np.pad(\n            wavelengths[start_order:end_order],\n            (0, order_size - slice_size),\n            constant_values=0,\n        )\n        reconstructed_S2D[order_number] = np.pad(\n            flux[start_order:end_order],\n            (0, order_size - slice_size),\n            constant_values=0,\n        )\n        reconstructed_uncertainties[order_number] = np.pad(\n            uncertainties[start_order:end_order],\n            (0, order_size - slice_size),\n            constant_values=0,\n        )\n        order_number += 1\n\n    # The \"new\" orders that don't have any information will have a flux of zero. Thus, they will be deemed to\n    # be invalid during the mask creation process (that is re-launched after this routine is done)\n\n    # Ensure that we don't lose information due to the SNR cut\n    user_configs = self._internal_configs._user_configs\n    user_configs[\"minimum_order_SNR\"] = 0\n\n    inst_properties = self.instrument_properties[\"array_sizes\"]\n    if new_S2D_size is not None:\n        inst_properties[\"S2D\"] = new_S2D_size\n\n    new_frame = Frame(\n        inst_name=self.inst_name,\n        array_size=inst_properties,\n        file_path=self.file_path,\n        frameID=self.frameID,\n        KW_map=self._KW_map,\n        available_indicators=self.available_indicators,\n        user_configs=self._internal_configs._user_configs,\n    )\n    new_frame.wavelengths = reconstructed_wavelengths\n    new_frame.spectra = reconstructed_S2D\n    new_frame.uncertainties = reconstructed_uncertainties\n    for key in [\"observation_info\", \"instrument_properties\"]:\n        setattr(new_frame, key, getattr(self, key))\n\n    new_frame._spectrum_has_data_on_memory = True  # to avoid new data loads!\n    new_frame._never_close = True  # ensure that we don't lose the transformation\n    new_frame.spectral_format = \"S2D\"\n    new_frame.instrument_properties[\"array_size\"] = new_S2D_size\n    new_frame.array_size = new_S2D_size\n    new_frame.sub_instrument = self.sub_instrument\n    new_frame.is_blaze_corrected = self.is_blaze_corrected\n    new_frame.observation_info[\"orderwise_SNRs\"] = [1 for _ in range(new_S2D_size[0])]\n    new_frame.regenerate_order_status()\n    return new_frame\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.finalize_data_load","title":"<code>finalize_data_load(bad_flag=None)</code>","text":"<p>Run for all Instruments, even those that do not need an external data load.</p> <p>Checks if the non-fatal Flag \"LOADING_EXTERNAL_DATA\" exists in the Status. If so, add the fatal Flag \"MISSING_EXTERNAL_DATA\". Otherwise, does nothing</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def finalize_data_load(self, bad_flag: Optional[Flag] = None) -&gt; None:\n    \"\"\"Run for all Instruments, even those that do not need an external data load.\n\n    Checks if the non-fatal Flag \"LOADING_EXTERNAL_DATA\" exists in the Status.\n    If so, add the fatal Flag \"MISSING_EXTERNAL_DATA\". Otherwise, does nothing\n\n    \"\"\"\n    if self._status.has_flag(LOADING_EXTERNAL_DATA):\n        logger.critical(f\"Frame {self.name} did not load the external data that it needed!\")\n\n        self._status.delete_flag(LOADING_EXTERNAL_DATA)\n        if bad_flag is None:\n            self.add_to_status(MISSING_EXTERNAL_DATA)\n        else:\n            self.add_to_status(bad_flag)\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.finalized_external_data_load","title":"<code>finalized_external_data_load()</code>","text":"<p>Mark frame after everything is loaded into memory.</p> <p>The frames that need external data will have a Flag of \"LOADING_EXTERNAL_DATA\" that will translate into a rejection of the Frame (if it is not removed).</p> <p>This call will remove that flag from Status and sinalizes that this Frame managed to load everything that it needed</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def finalized_external_data_load(self) -&gt; None:\n    \"\"\"Mark frame after everything is loaded into memory.\n\n    The frames that need external data will have a Flag of \"LOADING_EXTERNAL_DATA\" that will translate into a\n    rejection of the Frame (if it is not removed).\n\n    This call will remove that flag from Status and sinalizes that this Frame managed to load everything that\n    it needed\n    \"\"\"\n    if not self.is_valid:\n        logger.warning(\"Finalizing external data loading for Frame that was already rejected.\")\n    else:\n        self._status.delete_flag(LOADING_EXTERNAL_DATA)\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.find_instrument_type","title":"<code>find_instrument_type()</code>","text":"<p>Compare the date of observation with pre-defined sub-Instruments to see where it fits.</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def find_instrument_type(self) -&gt; None:\n    \"\"\"Compare the date of observation with pre-defined sub-Instruments to see where it fits.\"\"\"\n    obs_date = self.get_KW_value(\"ISO-DATE\")\n    obs_date = \"-\".join(obs_date.split(\"T\")).split(\":\")[0]\n    obs_date = datetime.datetime.strptime(obs_date, r\"%Y-%m-%d-%H\")\n\n    for key, threshold in self.__class__.sub_instruments.items():\n        # If it is not higher tha  the threshold, then it beleongs in this \"interval\"\n        if not obs_date &gt; threshold:\n            self.sub_instrument = key\n            break\n    else:\n        raise custom_exceptions.InternalError(\"no sub-instrument found for observation\")\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.get_KW_value","title":"<code>get_KW_value(KW)</code>","text":"<p>Get a given KW value that is defined in the common framework.</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def get_KW_value(self, KW: str) -&gt; Any:\n    \"\"\"Get a given KW value that is defined in the common framework.\"\"\"\n    return self.observation_info[KW]\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.get_S1D_name","title":"<code>get_S1D_name()</code>","text":"<p>Build the S1D name that should be associated with this Frame.</p> <p>If it is already a S1D, returns the actual name. If it is not, remove \"blaze\" from the filename and replaces \"S2D\" with \"S1D\"</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def get_S1D_name(self) -&gt; str:\n    \"\"\"Build the S1D name that should be associated with this Frame.\n\n    If it is already a S1D, returns the actual name.\n    If it is not, remove \"blaze\" from the filename and replaces \"S2D\" with \"S1D\"\n\n    \"\"\"\n    # TODO: this will not work for non-ESPRESSO files\n\n    if self.is_S1D:\n        return self.fname\n    name = self.fname\n    return name.replace(\"BLAZE_\", \"\").replace(\"S2D\", \"S1D\")\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.get_header_value","title":"<code>get_header_value(kw)</code>","text":"<p>Directly retrieves a KW from the header.</p> <p>After this is called, the frame will keep the header stored in memory until the object is deleted</p> <p>Parameters:</p> Name Type Description Default <code>kw</code> <code>str</code> <p>Keyword name, present in the fits header</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Header value</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def get_header_value(self, kw: str) -&gt; Any:\n    \"\"\"Directly retrieves a KW from the header.\n\n    After this is called, the frame will keep the header stored in memory until the object is deleted\n\n    Args:\n        kw (str): Keyword name, present in the fits header\n\n    Returns:\n        Any: Header value\n\n    \"\"\"\n    if self._header is None:\n        self._header = fits.getheader(self.file_path)\n    return self._header[kw]\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.get_spectral_type","title":"<code>get_spectral_type()</code>","text":"<p>Check the filename to see if we are using an S1D or S2D file.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If it is not possible to recognize the filename</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>S1D or S2D</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def get_spectral_type(self) -&gt; str:\n    \"\"\"Check the filename to see if we are using an S1D or S2D file.\n\n    Raises:\n        custom_exceptions.InternalError: If it is not possible to recognize the filename\n\n    Returns:\n        str: S1D or S2D\n\n    \"\"\"\n    name_lowercase = self.file_path.stem.lower()\n    if \"s2d\" in name_lowercase or \"e2ds\" in name_lowercase:\n        return \"S2D\"\n    if \"s1d\" in name_lowercase:\n        return \"S1D\"\n    raise custom_exceptions.InternalError(f\"{self.name} can't recognize the file that it received!\")\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.import_KW_from_outside","title":"<code>import_KW_from_outside(KW, value, optional)</code>","text":"<p>Allow to manually override header parameters (in memory) from the outside.</p> <p>This can be used if an instrument has data stored in multiple files. This allows a post-setup update of header values (for the keywords stored in observation_info)</p> <p>Parameters:</p> Name Type Description Default <code>KW</code> <code>str</code> <p>keyword name, as defined by the Frame interface</p> required <code>value</code> <code>Any</code> <p>New value</p> required <code>optional</code> <code>bool</code> <p>if it is optional, it can be a non-finite value</p> required <p>Raises:</p> Type Description <code>FrameError</code> <p>If we attempt to load a optional=False keyword that has a non-finite value</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def import_KW_from_outside(self, KW: str, value: Any, optional: bool) -&gt; None:\n    \"\"\"Allow to manually override header parameters (in memory) from the outside.\n\n    This can be used if an instrument has data stored in multiple files. This allows a post-setup\n    update of header values (for the keywords stored in observation_info)\n\n    Args:\n        KW (str): keyword name, as defined by the Frame interface\n        value (Any): New value\n        optional (bool): if it is optional, it can be a non-finite value\n\n    Raises:\n        FrameError: If we attempt to load a optional=False keyword that has a non-finite value\n\n    \"\"\"\n    if KW not in self.observation_info:\n        logger.critical(\n            \"Keyword &lt;{}&gt; is not supported by the Frames. Couldn't load it from the outside\",\n            KW,\n        )\n\n    if not np.isfinite(value):\n        if not optional:\n            logger.critical(\n                \"Loaded mandatory keyword &lt;{}&gt; with a non-finite value for frame {}\",\n                KW,\n                self.fname,\n            )\n            raise FrameError\n        logger.critical(\n            \"Loaded keyword &lt;{}&gt; has a non-finite value for frame {}\",\n            KW,\n            self.fname,\n        )\n    self.observation_info[KW] = value\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.is_Instrument","title":"<code>is_Instrument(Instrument)</code>","text":"<p>Check if Frame is from a given instrument.</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def is_Instrument(self, Instrument: str) -&gt; bool:\n    \"\"\"Check if Frame is from a given instrument.\"\"\"\n    return self.inst_name == Instrument\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.is_SubInstrument","title":"<code>is_SubInstrument(sub_instrument)</code>","text":"<p>Check if the current instrument is from the given time_block (e.g ESPRESSO18/ESPRESSO19).</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.is_SubInstrument--parameters","title":"Parameters","text":"<p>sub_instrument : str     Name of the time block that is going to be checked</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.is_SubInstrument--returns","title":"Returns","text":"<p>[bool]     Results from the comparison</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def is_SubInstrument(self, sub_instrument: str) -&gt; bool:\n    \"\"\"Check if the current instrument is from the given time_block (e.g ESPRESSO18/ESPRESSO19).\n\n    Parameters\n    ----------\n    sub_instrument : str\n        Name of the time block that is going to be checked\n\n    Returns\n    -------\n    [bool]\n        Results from the comparison\n\n    \"\"\"\n    return self.sub_instrument == sub_instrument\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.load_S1D_data","title":"<code>load_S1D_data()</code>","text":"<p>To be overriden by the children classes.</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def load_S1D_data(self) -&gt; None:\n    \"\"\"To be overriden by the children classes.\"\"\"\n    logger.debug(\"Opening the S1D arrays from {}\", self.fname)\n    if not self.is_valid:\n        raise FrameError\n    self._spectrum_has_data_on_memory = True\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.load_S2D_data","title":"<code>load_S2D_data()</code>","text":"<p>To be overriden by the children classes.</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def load_S2D_data(self) -&gt; None:\n    \"\"\"To be overriden by the children classes.\"\"\"\n    logger.debug(\"Opening the S2D arrays from {}\", self.fname)\n    if not self.is_valid:\n        raise FrameError\n    self._spectrum_has_data_on_memory = True\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.load_data","title":"<code>load_data()</code>","text":"<p>Abstraction to load all data of this Frame.</p> <p>If the Frame is already open, it does nothing. Calls the S1D or S2D version of the data load, depending on file type Can remove BERV correction at run time, if properly configured to do so.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If it is neither S2D or S1D</p> <code>FrameError</code> <p>If the frame is no longer valid after loading</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def load_data(self) -&gt; None:\n    \"\"\"Abstraction to load all data of this Frame.\n\n    If the Frame is already open, it does nothing.\n    Calls the S1D or S2D version of the data load, depending on file type\n    Can remove BERV correction at run time, if properly configured to do so.\n\n    Raises:\n        custom_exceptions.InternalError: If it is neither S2D or S1D\n        FrameError: If the frame is no longer valid after loading\n\n    \"\"\"\n    if self.is_open:\n        return\n\n    if self.is_S1D:\n        self.load_S1D_data()\n    elif self.is_S2D:\n        self.load_S2D_data()\n    else:\n        raise custom_exceptions.InternalError(\"something went wrong on this frame\")\n\n    if not self.is_valid:\n        raise FrameError(\"Frame is no longer valid\")\n\n    BERV_value = self.get_KW_value(\"BERV\")\n\n    if not self._internal_configs[\"open_without_BervCorr\"]:\n        self.apply_BERV_correction(BERV_value)\n    else:\n        logger.warning(f\"Opening {self.name} without the BERV correction\")\n        self.remove_BERV_correction(BERV_value)\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.load_header_info","title":"<code>load_header_info()</code>","text":"<p>Open the header of the fits file and load the necessary keywords.</p> <p>Does the following operations: 1) Load header assuming fits file 2) Parse through the _KW_map to load header keywords 3) Call self.load_instrument_specific_KWs 4) Call check_header_QC(hdu) 5) Call find_instrument_type() 6) Call assess_bad_orders()</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def load_header_info(self) -&gt; None:\n    \"\"\"Open the header of the fits file and load the necessary keywords.\n\n    Does the following operations:\n    1) Load header assuming fits file\n    2) Parse through the _KW_map to load header keywords\n    3) Call self.load_instrument_specific_KWs\n    4) Call check_header_QC(hdu)\n    5) Call find_instrument_type()\n    6) Call assess_bad_orders()\n\n    \"\"\"\n    try:\n        hdu = fits.getheader(self.file_path)\n    except FileNotFoundError:\n        msg = f\"File &lt;{self.file_path}&gt; does not exist\"\n        self.add_to_status(MISSING_FILE(msg))\n        logger.critical(msg)\n        return\n\n    for internal_KW, S2D_KW in self._KW_map.items():\n        self.observation_info[internal_KW] = hdu[S2D_KW]\n\n    self.load_instrument_specific_KWs(hdu)\n    self.check_header_QC(hdu)\n    self.find_instrument_type()\n    self.assess_bad_orders()\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.load_instrument_specific_KWs","title":"<code>load_instrument_specific_KWs(header)</code>","text":"<p>Load instrument-specific KW values that can't be loaded in a general fashion.</p> <p>To be overriden by the different instruments</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>Mapping[str, Any]</code> <p>header unit of this observation</p> required Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def load_instrument_specific_KWs(self, header: Mapping[str, Any]) -&gt; None:\n    \"\"\"Load instrument-specific KW values that can't be loaded in a general fashion.\n\n    To be overriden by the different instruments\n\n    Args:\n        header (Mapping[str, Any]): header unit of this observation\n\n    \"\"\"\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.mark_wavelength_region","title":"<code>mark_wavelength_region(reason, wavelength_blocks)</code>","text":"<p>Add wavelength regions to be removed whenever the S2D file is opened.</p> <p>When rejecting wavelengths through this function, we only have to specify wavelength intervels, allowing to account for possible order overlap. When loading the Frame, we search through all orders to find any occurence of this wavelength blocks.</p>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.mark_wavelength_region--parameters","title":"Parameters","text":"<p>reason : Flag     Flag for the removal type wavelength_blocks : list[tuple[int, int]]     List with lists of wavelength limits. [[lambda_0, lambda_1], [lambda_2, lambda_3]] to reject.z</p> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def mark_wavelength_region(self, reason: Flag, wavelength_blocks: list[tuple[int, int]]) -&gt; None:\n    \"\"\"Add wavelength regions to be removed whenever the S2D file is opened.\n\n    When rejecting wavelengths through this function, we only have to specify wavelength intervels, allowing\n    to account for possible order overlap. When loading the Frame, we search through all orders to find any\n    occurence of this wavelength blocks.\n\n    Parameters\n    ----------\n    reason : Flag\n        Flag for the removal type\n    wavelength_blocks : list[tuple[int, int]]\n        List with lists of wavelength limits. [[lambda_0, lambda_1], [lambda_2, lambda_3]] to reject.z\\\n\n    \"\"\"\n    self.wavelengths_to_remove[reason] = wavelength_blocks\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.plot_spectra","title":"<code>plot_spectra(which_orders=None, axis=None)</code>","text":"<p>Plot the spectra.</p> <p>Parameters:</p> Name Type Description Default <code>which_orders</code> <code>None | DETECTOR_DEFINITION | list[int]</code> <p>Either a pre-configured</p> <code>None</code> <code>axis</code> <code>_type_</code> <p>if None, create a new figure. Otherwise, use this one. Defaults to None.</p> <code>None</code> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def plot_spectra(\n    self,\n    which_orders: None | DETECTOR_DEFINITION | list[int] = None,\n    axis=None,\n):\n    \"\"\"Plot the spectra.\n\n    Args:\n        which_orders (None | DETECTOR_DEFINITION | list[int], optional): Either a pre-configured\n        detector definition, a list of orders, or None (plots all orders). Defaults to None.\n        axis (_type_, optional): if None, create a new figure. Otherwise, use this one. Defaults to None.\n\n    \"\"\"\n    fig = None\n    if axis is None:\n        fig, axis = plt.subplots()\n    wf, ff, ef, mf = self.get_data_from_full_spectrum()\n\n    if which_orders is None:\n        which_orders = DETECTOR_DEFINITION.WHITE_LIGHT\n\n    if isinstance(which_orders, (list, tuple)):\n        orders_to_plot = which_orders\n    else:\n        orders_to_plot = self.order_intervals[which_orders]\n\n    for sl in orders_to_plot:\n        w, f, e, m = wf[sl], ff[sl], ef[sl], mf[sl]\n        axis.errorbar(w[~m], f[~m], e[~m], ls=\"\", marker=\"x\")\n\n    return fig, axis\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.reject_wavelength_region_from_order","title":"<code>reject_wavelength_region_from_order(order, region)</code>","text":"<p>Flag a wavelength region from specific order to be marked as invalid during the creation of the stellar mask.</p> <p>This will not account for order overlaps.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>_type_</code> <p>description</p> required <code>region</code> <code>_type_</code> <p>description</p> required <p>Raises:</p> Type Description <code>InvalidConfiguration</code> Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def reject_wavelength_region_from_order(self, order: int, region: list[tuple[int, int]]) -&gt; None:\n    \"\"\"Flag a wavelength region from specific order to be marked as invalid during the creation of the stellar mask.\n\n    This will not account for order overlaps.\n\n    Args:\n        order (_type_): _description_\n        region (_type_): _description_\n\n    Raises:\n        custom_exceptions.InvalidConfiguration:\n\n    \"\"\"\n    if not isinstance(region, (Iterable,)):\n        raise custom_exceptions.InvalidConfiguration(\"The rejection region must be a list of lists\")\n\n    if self._orderwise_wavelength_rejection is None:\n        self._orderwise_wavelength_rejection = {}\n    self._orderwise_wavelength_rejection[order] = region\n</code></pre>"},{"location":"api/Frame/#ASTRA.base_models.Frame.Frame.select_wavelength_region","title":"<code>select_wavelength_region(order, wavelength_blocks)</code>","text":"<p>Reject all wavelengths that are not part of the provided intervals.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>Spectral order</p> required <code>wavelength_blocks</code> <code>list[list[int]]</code> <p>List of tuples, each containing wavelength of start and end</p> required Source code in <code>src/ASTRA/base_models/Frame.py</code> <pre><code>def select_wavelength_region(self, order: int, wavelength_blocks: list[tuple[int, int]]) -&gt; None:\n    \"\"\"Reject all wavelengths that are not part of the provided intervals.\n\n    Args:\n        order (int): Spectral order\n        wavelength_blocks (list[list[int]]): List of tuples, each containing wavelength of start and end\n        of each \"good\" interval\n\n    \"\"\"\n    if self.wavelengths_to_keep is None:\n        self.wavelengths_to_keep = {}\n    self.wavelengths_to_keep[order] = wavelength_blocks\n</code></pre>"},{"location":"api/Frame/#currently-available-interfaces-to-spectrographs","title":"Currently available interfaces to spectrographs","text":""},{"location":"api/Frame/#ASTRA.Instruments.ESPRESSO.ESPRESSO","title":"<code>ESPRESSO</code>","text":"<p>               Bases: <code>ESO_PIPELINE</code></p> <p>Interface to handle ESPRESSO observations (S2D and S1D).</p> <p>With ESPRESSO data we are considering 3 sub-Instruments:</p> <ul> <li>ESPRESSO18 - Before  2019-06-27</li> <li>ESPRESSO19 - Before  2020-12-18</li> <li>ESPRESSO21 - Until the ends of time (hopefully)</li> </ul> <p>User parameters:</p> <p>================================ ================ ================ ================ ================ Parameter name                      Mandatory      Default Value    Valid Values    Comment ================================ ================ ================ ================ ================ ================================ ================ ================ ================ ================</p> <p>.. note::     Also check the User parameters of the parent classes for further customization options of SBART</p> Source code in <code>src/ASTRA/Instruments/ESPRESSO.py</code> <pre><code>class ESPRESSO(ESO_PIPELINE):\n    \"\"\"Interface to handle ESPRESSO observations (S2D and S1D).\n\n    With ESPRESSO data we are considering 3 sub-Instruments:\n\n    * ESPRESSO18 - Before  2019-06-27\n    * ESPRESSO19 - Before  2020-12-18\n    * ESPRESSO21 - Until the ends of time (hopefully)\n\n\n    **User parameters:**\n\n    ================================ ================ ================ ================ ================\n    Parameter name                      Mandatory      Default Value    Valid Values    Comment\n    ================================ ================ ================ ================ ================\n    ================================ ================ ================ ================ ================\n\n    .. note::\n        Also check the **User parameters** of the parent classes for further customization options of SBART\n\n    \"\"\"\n\n    _default_params = ESO_PIPELINE._default_params\n\n    sub_instruments = {\n        \"ESPRESSO18\": datetime.datetime.strptime(\"2019-06-27\", r\"%Y-%m-%d\"),\n        \"ESPRESSO19\": datetime.datetime.max,\n        # \"ESPRESSO19\": datetime.datetime.strptime(\"2020-12-18\", r\"%Y-%m-%d\"),\n    }\n    _name = \"ESPRESSO\"\n\n    order_intervals: dict[DETECTOR_DEFINITION, slice] = {\n        DETECTOR_DEFINITION.WHITE_LIGHT: list(range(170)),\n        DETECTOR_DEFINITION.RED_DET: list(range(90, 170)),\n        DETECTOR_DEFINITION.BLUE_DET: list(range(0, 90)),\n    }\n\n    def __init__(\n        self,\n        file_path,\n        user_configs: Optional[Dict[str, Any]] = None,\n        reject_subInstruments: Optional[Iterable[str]] = None,\n        frameID: Optional[int] = None,\n        quiet_user_params: bool = True,\n    ):\n        \"\"\"ESPRESSO interface.\n\n        Parameters\n        ----------\n        file_path\n            Path to the S2D (or S1D) file.\n        user_configs\n            Dictionary whose keys are the configurable options of ESPRESSO (check above)\n        reject_subInstruments\n            Iterable of subInstruments to fully reject\n        frameID\n            ID for this observation. Only used for organization purposes by :class:`~SBART.data_objects.DataClass`\n\n        \"\"\"\n        # Wavelength coverage\n\n        coverage = (350, 900)\n\n        super().__init__(\n            inst_name=\"ESPRESSO\",\n            array_size={\"S2D\": (170, 9111), \"S1D\": (1, 443262)},\n            file_path=file_path,\n            frameID=frameID,\n            KW_identifier=\"ESO\",\n            user_configs=user_configs,\n            reject_subInstruments=reject_subInstruments,\n            quiet_user_params=quiet_user_params,\n        )\n\n        self.instrument_properties[\"wavelength_coverage\"] = coverage\n        self.instrument_properties[\"resolution\"] = 140_000\n        self.instrument_properties[\"EarthLocation\"] = EarthLocation.of_site(\"Cerro Paranal\")\n        self.instrument_properties[\"is_drift_corrected\"] = True\n\n        # https://www.eso.org/sci/facilities/paranal/astroclimate/site.html\n        self.instrument_properties[\"site_pressure\"] = 750\n\n    def load_telemetry_info(self, header):\n        # Find the UT number and load the airmass\n        for i in range(1, 5):\n            try:\n                self.observation_info[\"airmass\"] = header[f\"HIERARCH ESO TEL{i} AIRM START\"]\n                self.UT_number = i\n                break\n            except KeyError as e:\n                if i == 4:\n                    msg = \"\\tCannot find ESO TELx AIRM START key\"\n                    raise KeyError(msg) from e\n\n        # Environmental KWs for telfit (also needs airmassm previously loaded)\n        ambi_KWs = {\n            \"relative_humidity\": \"AMBI RHUM\",\n            \"ambient_temperature\": \"AMBI TEMP\",\n            \"seeing\": \"AMBI FWHM START\",\n        }\n\n        for name, endKW in ambi_KWs.items():\n            self.observation_info[name] = float(header[f\"HIERARCH ESO TEL{self.UT_number} {endKW}\"])\n            if \"temperature\" in name:  # store temperature in KELVIN for TELFIT\n                self.observation_info[name] = convert_temperature(\n                    self.observation_info[name],\n                    old_scale=\"Celsius\",\n                    new_scale=\"Kelvin\",\n                )\n\n        self.observation_info[\"DET_BINX\"] = header[\"HIERARCH ESO DET BINX\"]\n        self.observation_info[\"DET_BINY\"] = header[\"HIERARCH ESO DET BINY\"]\n\n    def check_header_QC_ESO_DRS(self, header):\n        nonfatal_QC_flags = {\n            \"HIERARCH ESO INS{} ADC{} RA\": 0,  # related with ADC2 problem\n            \"HIERARCH ESO INS{} ADC{} dec\": 0,  # related with ADC2 problem\n            \"HIERARCH ESO INS{} ADC{} SENS1\": 0,  # related with ADC2 problem\n            \"HIERARCH ESO INS{} ADC{} TEMP\": 0,  # related with ADC2 problem\n        }\n        found_ADC_issue = False\n        for flag, bad_value in nonfatal_QC_flags.items():\n            found_UT = False\n            for UT_KW in [\"\", \"2\", \"3\", \"4\"]:\n                try:\n                    for ADC in [1, 2]:\n                        ADC_KW = flag.format(UT_KW, ADC)\n                        if header[ADC_KW] == bad_value:\n                            msg = f\"QC flag {ADC_KW} has a value of {bad_value}\"\n                            logger.warning(msg)\n                            self._status.store_warning(KW_WARNING(msg))\n                            found_ADC_issue = True\n                        found_UT = True\n                except:\n                    pass\n            if not found_UT:\n                logger.critical(f\"Did not find the entry for the following UT related metric: {flag}\")\n\n        if found_ADC_issue:\n            self._status.store_warning(KW_WARNING(\"ADC2 issues found\"))\n\n        super().check_header_QC_ESO_DRS(header)\n\n    def build_mask(self, bypass_QualCheck: bool = False) -&gt; None:\n        super().build_mask(bypass_QualCheck=bypass_QualCheck, assess_bad_orders=False)\n\n        if self.spectral_format == \"S2D\":\n            # the first two orders of the RED CCD have a large amount of noise in the beginning so we remove a\n            # portion from the start of those two orders Now, what is going on: we want to find the indexes,\n            # from order 90 and 91 that are below the 5230 \\AA\n            inds = np.where(self.wavelengths[90:92, :] &lt;= 5230)\n            # numpy where returns the indexes assuming the zero to be 90 and the one to be 91. Remember that we\n            # sliced the array to only remove from those two orders\n            inds_1 = np.where(inds[0], 91, 90)\n            # rebuild the 'numpy where' output, to pass to the mask as the proper output\n            inds = (inds_1, inds[1])\n            self.spectral_mask.add_indexes_to_mask(inds, ERROR_THRESHOLD)\n\n        self.assess_bad_orders()\n\n    def trigger_data_storage(self, *args, **kwargs):\n        super().trigger_data_storage(*args, **kwargs)\n</code></pre>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS","title":"<code>HARPS</code>","text":"<p>               Bases: <code>ESO_PIPELINE</code></p> <p>Interface to handle HARPS data; S1D not supported.</p> <p>This class also defines 2 sub-Instruments:</p> <ul> <li>HARPSpre - Before  2015-05-29</li> <li>HARPSpost - Until the ends of time (hopefully)</li> </ul> <p>The steps to load the S2D data are described in the HARPS <code>DRS manual &lt;https://www.eso.org/sci/facilities/lasilla/instruments/harps/doc/DRS.pdf&gt;</code>_. The summary is:</p> <pre><code>- Construct the wavelength solution &amp; correct from BERV\n- Load instrumental drift\n- Construct flux noises:\n\n    - Table 10 of `the user manual &lt;https://www.eso.org/sci/facilities/lasilla/instruments/harps/doc/manual/HARPS-UserManual2.4.pdf&gt;`_ gives max RON of 7.07 for red detector\n    - Noise = sqrt(obj + sky + n*dark*expTime + nBinY*ron^2)\n</code></pre> <p>User parameters:</p> <p>Currently there are no HARPS-specific parameters</p> <p>Note: Check the User parameters of the parent classes for further customization options of SBART</p> Source code in <code>src/ASTRA/Instruments/HARPS.py</code> <pre><code>class HARPS(ESO_PIPELINE):\n    \"\"\"Interface to handle HARPS data; S1D **not** supported.\n\n    This class also defines 2 sub-Instruments:\n\n    * HARPSpre - Before  2015-05-29\n    * HARPSpost - Until the ends of time (hopefully)\n\n    The steps to load the S2D data are described in the HARPS `DRS manual &lt;https://www.eso.org/sci/facilities/lasilla/instruments/harps/doc/DRS.pdf&gt;`_. The summary is:\n\n        - Construct the wavelength solution &amp; correct from BERV\n        - Load instrumental drift\n        - Construct flux noises:\n\n            - Table 10 of `the user manual &lt;https://www.eso.org/sci/facilities/lasilla/instruments/harps/doc/manual/HARPS-UserManual2.4.pdf&gt;`_ gives max RON of 7.07 for red detector\n            - Noise = sqrt(obj + sky + n*dark*expTime + nBinY*ron^2)\n\n    **User parameters:**\n\n     Currently there are no HARPS-specific parameters\n\n    *Note:* Check the **User parameters** of the parent classes for further customization options of SBART\n\n    \"\"\"\n\n    sub_instruments = {\n        \"HARPS03\": datetime.datetime.strptime(\"2015-05-29\", r\"%Y-%m-%d\"),\n        \"HARPS15\": datetime.datetime.max,\n    }\n\n    _name = \"HARPS\"\n    _default_params = ESO_PIPELINE._default_params\n\n    order_intervals: dict[DETECTOR_DEFINITION, slice] = {\n        DETECTOR_DEFINITION.WHITE_LIGHT: list(range(0, 71)),\n        DETECTOR_DEFINITION.RED_DET: list(range(47, 71)),\n        DETECTOR_DEFINITION.BLUE_DET: list(range(0, 47)),\n    }\n\n    def __init__(\n        self,\n        file_path,\n        user_configs: Optional[Dict[str, Any]] = None,\n        reject_subInstruments=None,\n        frameID=None,\n        quiet_user_params: bool = True,\n    ):\n        \"\"\"HARPS constructor.\n\n        Parameters\n        ----------\n        file_path\n            Path to the S2D (or S1D) file.\n        user_configs\n            Dictionary whose keys are the configurable options of ESPRESSO (check above)\n        reject_subInstruments\n            Iterable of subInstruments to fully reject\n        frameID\n            ID for this observation. Only used for organization purposes by :class:`~SBART.data_objects.DataClass`\n\n        \"\"\"\n        logger.info(f\"Creating frame from: {file_path}\")\n\n        coverage = [350, 700]\n        # Note: 46 blue orders and 26 red orders. From Table 2.2 of:\n        # https://www.eso.org/sci/facilities/lasilla/instruments/harps/doc/manual/HARPS-UserManual2.4.pdf\n        if user_configs[\"use_old_pipeline\"]:\n            mat_size = (72, 4096)\n            KW_map = {\n                \"OBJECT\": \"OBJECT\",\n                \"BJD\": \"HIERARCH ESO DRS BJD\",\n                \"MJD\": \"MJD-OBS\",\n                \"ISO-DATE\": \"DATE-OBS\",\n                \"DRS-VERSION\": \"HIERARCH ESO DRS VERSION\",\n                \"RA\": \"RA\",\n                \"DEC\": \"DEC\",\n                \"MD5-CHECK\": \"DATASUM\",\n                \"SPEC_TYPE\": None,\n                \"DRS_CCF_MASK\": None,\n                \"DRS_FLUX_CORRECTION_TEMPLATE\": None,\n            }\n        else:\n            mat_size = (71, 4096)\n            KW_map = {}\n\n        if user_configs[\"use_old_pipeline\"]:\n            file_path, self.ccf_path, self.BIS_file, search_status = self.find_files(file_path)\n\n        super().__init__(\n            inst_name=\"HARPS\",\n            array_size={\"S2D\": mat_size},\n            file_path=file_path,\n            KW_identifier=\"ESO\",\n            frameID=frameID,\n            user_configs=user_configs,\n            reject_subInstruments=reject_subInstruments,\n            quiet_user_params=quiet_user_params,\n            override_KW_map=KW_map,\n            override_indicators=(\"CONTRAST\", \"FWHM\"),\n        )\n\n        if user_configs[\"use_old_pipeline\"] and not search_status.is_good_flag:\n            self.add_to_status(search_status)\n\n        self.instrument_properties[\"wavelength_coverage\"] = coverage\n\n        if user_configs[\"use_old_pipeline\"]:\n            self.instrument_properties[\"is_drift_corrected\"] = False\n            self.is_BERV_corrected = False\n\n        self.instrument_properties[\"resolution\"] = 115_000\n        self.instrument_properties[\"EarthLocation\"] = EarthLocation.of_site(\"La Silla Observatory\")\n        # ? same as for Paranal?\n        # https://www.eso.org/sci/facilities/paranal/astroclimate/site.html\n        self.instrument_properties[\"site_pressure\"] = 750\n        self.is_blaze_corrected = False\n\n    def load_telemetry_info(self, header):\n        \"\"\"Loads (at least) the following keywords:\n\n        - relative humidity\n        - ambient temperature, in Celsius\n        - airmass\n        - Detector\n\n        Parameters\n        ----------\n        header\n\n        Returns\n        -------\n\n        \"\"\"\n        ambi_KWs = {\n            \"relative_humidity\": \"RHUM\",\n            \"ambient_temperature\": \"TEMP\",\n        }\n\n        for name, endKW in ambi_KWs.items():\n            self.observation_info[name] = header[f\"HIERARCH {self.KW_identifier} TEL AMBI {endKW}\"]\n            if \"temperature\" in name:  # store temperature in KELVIN for TELFIT\n                self.observation_info[name] = convert_temperature(\n                    self.observation_info[name],\n                    old_scale=\"Celsius\",\n                    new_scale=\"Kelvin\",\n                )\n\n        if self.observation_info[\"relative_humidity\"] == 255:\n            logger.warning(f\"{self.name} has an invalid value in the humidity sensor...\")\n            self.observation_info[\"relative_humidity\"] = np.nan\n\n        self.observation_info[\"airmass\"] = header[\"HIERARCH ESO TEL AIRM START\"]\n\n    def find_files(self, file_name):\n        \"\"\"Find the CCF and S2D files and BIS files, which should be stored inside the same folder\"\"\"\n        logger.debug(\"Searching for the ccf and e2ds files\")\n\n        search_status = MISSING_DATA(\"Missing the ccf file\")\n        ccf_path = None\n        bis_path = None\n\n        if os.path.isdir(file_name):\n            logger.debug(\"Received a folder, searching inside for necessary files\")\n            # search for e2ds file\n            folder_name = file_name\n\n            e2ds_files = glob.glob(os.path.join(folder_name, \"*e2ds_A.fits\"), recursive=True)\n            ccf_files = glob.glob(os.path.join(folder_name, \"*ccf*A.fits\"), recursive=True)\n            bis_files = glob.glob(os.path.join(folder_name, \"*bis*A.fits\"), recursive=True)\n\n            for name, elems in [\n                (\"e2ds_A\", e2ds_files),\n                (\"ccf\", ccf_files),\n                (\"bis\", bis_files),\n            ]:\n                if len(elems) &gt; 1:\n                    msg = f\"HARPS data only received folder name and it has more than 1 {name} file in it\"\n                    raise custom_exceptions.InvalidConfiguration(msg)\n\n                if len(elems) &lt; 1:\n                    msg = f\"HARPS data only received folder name and it has no {name} file in it\"\n                    if name != \"bis\":\n                        # The BIS file is not critical for the run\n                        raise custom_exceptions.InvalidConfiguration(msg)\n                    logger.critical(msg)\n\n            e2ds_path = e2ds_files[0]\n            ccf_path = ccf_files[0]\n            bis_path = bis_files[0]\n            search_status = SUCCESS(\"Found all input files\")\n        else:\n            logger.debug(\"Received path of E2DS file; searching for CCF with matching name\")\n            folder_name = os.path.dirname(file_name)\n            e2ds_path = file_name\n            file_start, *_ = os.path.basename(file_name).split(\"_\")\n\n            found_CCF = False\n            found_BIS = False\n            ccf_files = glob.glob(os.path.join(folder_name, \"*ccf*A.fits\"), recursive=True)\n            bis_files = glob.glob(os.path.join(folder_name, \"*bis*A.fits\"), recursive=True)\n            for file in ccf_files:\n                if file_start in file:\n                    ccf_path = file\n                    found_CCF = True\n\n            for file in bis_files:\n                if file_start in file:\n                    bis_path = file\n                    found_BIS = True\n            if found_CCF:\n                logger.info(f\"Found CCF file: {ccf_path}\")\n                search_status = SUCCESS(\"Found CCF file\")\n            else:\n                logger.critical(\"Was not able to find CCF file. Marking frame as invalid\")\n                ccf_path = \"\"\n\n            if not found_BIS:\n                bis_path = None\n\n        return e2ds_path, ccf_path, bis_path, search_status\n\n    def build_HARPS_wavelengths(self, hdr):\n        \"\"\"Compute the wavelength solution to this given spectra (EQ 4.1 of DRS manual)\n        Convert from air wavelenbgths to vacuum\n        \"\"\"\n        # degree of the polynomial\n        d = hdr[\"HIERARCH ESO DRS CAL TH DEG LL\"]\n        # number of orders\n        omax = hdr.get(\"HIERARCH ESO DRS CAL LOC NBO\", self.array_size[0])\n        xmax = self.array_size[1]\n\n        # matrix X:\n        #\n        # axis 0: the entry corresponding to each coefficient\n        # axis 1: each pixel number\n\n        x = np.empty((d + 1, xmax), \"int64\")\n        x[0].fill(1)  # x[0,*] = x^0 = 1,1,1,1,1,...\n        x[1] = np.arange(xmax)\n\n        for i in range(1, d):\n            x[i + 1] = x[i] * x[1]\n\n        # matrix A:\n        #\n        # axis 0: the different orders\n        # axis 1: all coefficients for the given order\n\n        A = np.reshape(\n            [hdr[\"HIERARCH ESO DRS CAL TH COEFF LL\" + str(i)] for i in range(omax * (d + 1))],\n            (omax, d + 1),\n        )  # slow 30 ms\n\n        # the wavelengths for each order are a simple dot product between the coefficients and pixel-wise data (X)\n        wavelengths = np.dot(A, x)\n\n        vacuum_wavelengths = airtovac(wavelengths)\n        return vacuum_wavelengths\n\n    def _load_old_DRS_KWs(self, header):\n        if not self._internal_configs[\"use_old_pipeline\"]:\n            raise custom_exceptions.InvalidConfiguration(\"Can't load data from old pipeline without the config\")\n\n        self.observation_info[\"MAX_BERV\"] = header[\"HIERARCH ESO DRS BERVMX\"] * kilometer_second\n        self.observation_info[\"BERV\"] = header[\"HIERARCH ESO DRS BERV\"] * kilometer_second\n\n        # Environmental KWs for telfit (also needs airmassm previously loaded)\n        ambi_KWs = {\n            \"relative_humidity\": \"AMBI RHUM\",\n            \"ambient_temperature\": \"AMBI TEMP\",\n        }\n\n        for name, endKW in ambi_KWs.items():\n            self.observation_info[name] = header[f\"HIERARCH ESO TEL {endKW}\"]\n            if \"temperature\" in name:  # store temperature in KELVIN for TELFIT\n                self.observation_info[name] = convert_temperature(\n                    self.observation_info[name],\n                    old_scale=\"Celsius\",\n                    new_scale=\"Kelvin\",\n                )\n\n        for order in range(self.N_orders):\n            self.observation_info[\"orderwise_SNRs\"].append(header[f\"HIERARCH ESO DRS SPE EXT SN{order}\"])\n\n        self.observation_info[\"airmass\"] = header[\"HIERARCH ESO TEL AIRM START\"]\n\n        bad_drift = False\n        try:\n            flag = \"HIERARCH ESO DRS DRIFT QC\"\n            if header[flag].strip() != \"PASSED\":\n                bad_drift = True\n                msg = f\"QC flag {flag} meets the bad value\"\n                logger.warning(msg)\n                self._status.store_warning(KW_WARNING(msg))\n            else:\n                # self.logger.info(\"DRIFT QC has passed\")\n                drift = header[\"HIERARCH ESO DRS DRIFT RV USED\"] * meter_second\n                drift_err = header[\"HIERARCH ESO DRS DRIFT NOISE\"] * meter_second\n        except Exception:\n            bad_drift = True\n            logger.warning(\"DRIFT KW does not exist\")\n\n        if bad_drift:\n            logger.warning(\"Due to previous drift-related problems, setting it to zero [m/s]\")\n            drift = 0 * meter_second\n            drift_err = 0 * meter_second\n\n        self.observation_info[\"drift\"] = drift\n        self.observation_info[\"drift_ERR\"] = drift_err\n        self.load_ccf_data()\n\n    def load_ccf_data(self) -&gt; None:\n        \"\"\"Load the necessarfy CCF data from the file!\"\"\"\n        logger.debug(\"Loading data from the ccf file\")\n        header = fits.getheader(self.ccf_path)\n\n        self.observation_info[\"DRS_RV\"] = header[\"HIERARCH ESO DRS CCF RV\"] * kilometer_second\n        self.observation_info[\"SPEC_TYPE\"] = header[\"HIERARCH ESO DRS CCF MASK\"]\n\n        RV_err = np.sqrt(\n            header[\"HIERARCH ESO DRS CAL TH ERROR\"] ** 2\n            +\n            # hdulist[0].header['HIERARCH ESO DRS DRIFT NOISE']**2   +\n            (1000 * header[\"HIERARCH ESO DRS CCF NOISE\"]) ** 2,\n        )\n        self.observation_info[\"DRS_RV_ERR\"] = RV_err * meter_second\n\n        for key in self.available_indicators:\n            full_key = \"HIERARCH ESO DRS CCF \" + key\n            self.observation_info[key] = header[full_key]\n\n        # We are missing error in CONTRAST!\n        self.observation_info[\"FWHM_ERR\"] = convert_data(\n            2.35 * RV_err * meter_second,\n            new_units=kilometer_second,\n            as_value=True,\n        )\n        self.observation_info[\"BIS SPAN_ERR\"] = convert_data(\n            np.sqrt(2) * RV_err * meter_second,\n            new_units=kilometer_second,\n            as_value=True,\n        )\n\n        if self.BIS_file is not None:\n            head = fits.getheader(self.BIS_file)\n            self.observation_info[\"BIS SPAN\"] = head[\"HIERARCH ESO DRS BIS SPAN\"]\n\n    def load_S1D_data(self) -&gt; Mask:\n        raise NotImplementedError\n\n    def check_header_QC_old_DRS(self, header):\n        logger.info(\"Currently missing QC checks for the old DRS\")\n\n    def load_old_DRS_S2D(self):\n        \"\"\"Loads the spectra\n\n        Returns\n        -------\n\n        \"\"\"\n        super().load_S2D_data()\n\n        with fits.open(self.file_path) as hdulist:\n            # Compute the wavelength solution + BERV correction\n            wave_from_file = self.build_HARPS_wavelengths(hdulist[0].header)\n\n            sci_data = hdulist[0].data  # spetra from all orders\n\n            # photon noise + estimate of max value for the rest\n            # from ETC calculator the readout noise should be the largest contribution\n            # assuming that it is of ~7e- (equal to manual) it should have a maximum contribution\n            # of 200\n            flux_errors = np.sqrt(250 + np.abs(sci_data, dtype=float))\n\n            # Validate for overflows and missing data\n            quality_data = np.zeros(sci_data.shape)\n            quality_data[np.where(np.isnan(sci_data))] = NAN_DATA.code\n            quality_data[np.where(sci_data &gt; 300000)] = SATURATION.code\n            quality_data[np.where(sci_data &lt; -3 * flux_errors)] = ERROR_THRESHOLD.code\n\n        self.spectra = sci_data.astype(np.float64)\n        self.wavelengths = wave_from_file\n        self.qual_data = quality_data\n        self.uncertainties = flux_errors.astype(np.float64)\n\n        self.build_mask(bypass_QualCheck=False)\n        return 1\n\n    def close_arrays(self):\n        super().close_arrays()\n        if self._internal_configs[\"use_old_pipeline\"]:\n            self.is_BERV_corrected = False\n</code></pre>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.build_HARPS_wavelengths","title":"<code>build_HARPS_wavelengths(hdr)</code>","text":"<p>Compute the wavelength solution to this given spectra (EQ 4.1 of DRS manual) Convert from air wavelenbgths to vacuum</p> Source code in <code>src/ASTRA/Instruments/HARPS.py</code> <pre><code>def build_HARPS_wavelengths(self, hdr):\n    \"\"\"Compute the wavelength solution to this given spectra (EQ 4.1 of DRS manual)\n    Convert from air wavelenbgths to vacuum\n    \"\"\"\n    # degree of the polynomial\n    d = hdr[\"HIERARCH ESO DRS CAL TH DEG LL\"]\n    # number of orders\n    omax = hdr.get(\"HIERARCH ESO DRS CAL LOC NBO\", self.array_size[0])\n    xmax = self.array_size[1]\n\n    # matrix X:\n    #\n    # axis 0: the entry corresponding to each coefficient\n    # axis 1: each pixel number\n\n    x = np.empty((d + 1, xmax), \"int64\")\n    x[0].fill(1)  # x[0,*] = x^0 = 1,1,1,1,1,...\n    x[1] = np.arange(xmax)\n\n    for i in range(1, d):\n        x[i + 1] = x[i] * x[1]\n\n    # matrix A:\n    #\n    # axis 0: the different orders\n    # axis 1: all coefficients for the given order\n\n    A = np.reshape(\n        [hdr[\"HIERARCH ESO DRS CAL TH COEFF LL\" + str(i)] for i in range(omax * (d + 1))],\n        (omax, d + 1),\n    )  # slow 30 ms\n\n    # the wavelengths for each order are a simple dot product between the coefficients and pixel-wise data (X)\n    wavelengths = np.dot(A, x)\n\n    vacuum_wavelengths = airtovac(wavelengths)\n    return vacuum_wavelengths\n</code></pre>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.find_files","title":"<code>find_files(file_name)</code>","text":"<p>Find the CCF and S2D files and BIS files, which should be stored inside the same folder</p> Source code in <code>src/ASTRA/Instruments/HARPS.py</code> <pre><code>def find_files(self, file_name):\n    \"\"\"Find the CCF and S2D files and BIS files, which should be stored inside the same folder\"\"\"\n    logger.debug(\"Searching for the ccf and e2ds files\")\n\n    search_status = MISSING_DATA(\"Missing the ccf file\")\n    ccf_path = None\n    bis_path = None\n\n    if os.path.isdir(file_name):\n        logger.debug(\"Received a folder, searching inside for necessary files\")\n        # search for e2ds file\n        folder_name = file_name\n\n        e2ds_files = glob.glob(os.path.join(folder_name, \"*e2ds_A.fits\"), recursive=True)\n        ccf_files = glob.glob(os.path.join(folder_name, \"*ccf*A.fits\"), recursive=True)\n        bis_files = glob.glob(os.path.join(folder_name, \"*bis*A.fits\"), recursive=True)\n\n        for name, elems in [\n            (\"e2ds_A\", e2ds_files),\n            (\"ccf\", ccf_files),\n            (\"bis\", bis_files),\n        ]:\n            if len(elems) &gt; 1:\n                msg = f\"HARPS data only received folder name and it has more than 1 {name} file in it\"\n                raise custom_exceptions.InvalidConfiguration(msg)\n\n            if len(elems) &lt; 1:\n                msg = f\"HARPS data only received folder name and it has no {name} file in it\"\n                if name != \"bis\":\n                    # The BIS file is not critical for the run\n                    raise custom_exceptions.InvalidConfiguration(msg)\n                logger.critical(msg)\n\n        e2ds_path = e2ds_files[0]\n        ccf_path = ccf_files[0]\n        bis_path = bis_files[0]\n        search_status = SUCCESS(\"Found all input files\")\n    else:\n        logger.debug(\"Received path of E2DS file; searching for CCF with matching name\")\n        folder_name = os.path.dirname(file_name)\n        e2ds_path = file_name\n        file_start, *_ = os.path.basename(file_name).split(\"_\")\n\n        found_CCF = False\n        found_BIS = False\n        ccf_files = glob.glob(os.path.join(folder_name, \"*ccf*A.fits\"), recursive=True)\n        bis_files = glob.glob(os.path.join(folder_name, \"*bis*A.fits\"), recursive=True)\n        for file in ccf_files:\n            if file_start in file:\n                ccf_path = file\n                found_CCF = True\n\n        for file in bis_files:\n            if file_start in file:\n                bis_path = file\n                found_BIS = True\n        if found_CCF:\n            logger.info(f\"Found CCF file: {ccf_path}\")\n            search_status = SUCCESS(\"Found CCF file\")\n        else:\n            logger.critical(\"Was not able to find CCF file. Marking frame as invalid\")\n            ccf_path = \"\"\n\n        if not found_BIS:\n            bis_path = None\n\n    return e2ds_path, ccf_path, bis_path, search_status\n</code></pre>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.load_ccf_data","title":"<code>load_ccf_data()</code>","text":"<p>Load the necessarfy CCF data from the file!</p> Source code in <code>src/ASTRA/Instruments/HARPS.py</code> <pre><code>def load_ccf_data(self) -&gt; None:\n    \"\"\"Load the necessarfy CCF data from the file!\"\"\"\n    logger.debug(\"Loading data from the ccf file\")\n    header = fits.getheader(self.ccf_path)\n\n    self.observation_info[\"DRS_RV\"] = header[\"HIERARCH ESO DRS CCF RV\"] * kilometer_second\n    self.observation_info[\"SPEC_TYPE\"] = header[\"HIERARCH ESO DRS CCF MASK\"]\n\n    RV_err = np.sqrt(\n        header[\"HIERARCH ESO DRS CAL TH ERROR\"] ** 2\n        +\n        # hdulist[0].header['HIERARCH ESO DRS DRIFT NOISE']**2   +\n        (1000 * header[\"HIERARCH ESO DRS CCF NOISE\"]) ** 2,\n    )\n    self.observation_info[\"DRS_RV_ERR\"] = RV_err * meter_second\n\n    for key in self.available_indicators:\n        full_key = \"HIERARCH ESO DRS CCF \" + key\n        self.observation_info[key] = header[full_key]\n\n    # We are missing error in CONTRAST!\n    self.observation_info[\"FWHM_ERR\"] = convert_data(\n        2.35 * RV_err * meter_second,\n        new_units=kilometer_second,\n        as_value=True,\n    )\n    self.observation_info[\"BIS SPAN_ERR\"] = convert_data(\n        np.sqrt(2) * RV_err * meter_second,\n        new_units=kilometer_second,\n        as_value=True,\n    )\n\n    if self.BIS_file is not None:\n        head = fits.getheader(self.BIS_file)\n        self.observation_info[\"BIS SPAN\"] = head[\"HIERARCH ESO DRS BIS SPAN\"]\n</code></pre>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.load_old_DRS_S2D","title":"<code>load_old_DRS_S2D()</code>","text":"<p>Loads the spectra</p>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.load_old_DRS_S2D--returns","title":"Returns","text":"Source code in <code>src/ASTRA/Instruments/HARPS.py</code> <pre><code>def load_old_DRS_S2D(self):\n    \"\"\"Loads the spectra\n\n    Returns\n    -------\n\n    \"\"\"\n    super().load_S2D_data()\n\n    with fits.open(self.file_path) as hdulist:\n        # Compute the wavelength solution + BERV correction\n        wave_from_file = self.build_HARPS_wavelengths(hdulist[0].header)\n\n        sci_data = hdulist[0].data  # spetra from all orders\n\n        # photon noise + estimate of max value for the rest\n        # from ETC calculator the readout noise should be the largest contribution\n        # assuming that it is of ~7e- (equal to manual) it should have a maximum contribution\n        # of 200\n        flux_errors = np.sqrt(250 + np.abs(sci_data, dtype=float))\n\n        # Validate for overflows and missing data\n        quality_data = np.zeros(sci_data.shape)\n        quality_data[np.where(np.isnan(sci_data))] = NAN_DATA.code\n        quality_data[np.where(sci_data &gt; 300000)] = SATURATION.code\n        quality_data[np.where(sci_data &lt; -3 * flux_errors)] = ERROR_THRESHOLD.code\n\n    self.spectra = sci_data.astype(np.float64)\n    self.wavelengths = wave_from_file\n    self.qual_data = quality_data\n    self.uncertainties = flux_errors.astype(np.float64)\n\n    self.build_mask(bypass_QualCheck=False)\n    return 1\n</code></pre>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.load_telemetry_info","title":"<code>load_telemetry_info(header)</code>","text":"<p>Loads (at least) the following keywords:</p> <ul> <li>relative humidity</li> <li>ambient temperature, in Celsius</li> <li>airmass</li> <li>Detector</li> </ul>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.load_telemetry_info--parameters","title":"Parameters","text":"<p>header</p>"},{"location":"api/Frame/#ASTRA.Instruments.HARPS.HARPS.load_telemetry_info--returns","title":"Returns","text":"Source code in <code>src/ASTRA/Instruments/HARPS.py</code> <pre><code>def load_telemetry_info(self, header):\n    \"\"\"Loads (at least) the following keywords:\n\n    - relative humidity\n    - ambient temperature, in Celsius\n    - airmass\n    - Detector\n\n    Parameters\n    ----------\n    header\n\n    Returns\n    -------\n\n    \"\"\"\n    ambi_KWs = {\n        \"relative_humidity\": \"RHUM\",\n        \"ambient_temperature\": \"TEMP\",\n    }\n\n    for name, endKW in ambi_KWs.items():\n        self.observation_info[name] = header[f\"HIERARCH {self.KW_identifier} TEL AMBI {endKW}\"]\n        if \"temperature\" in name:  # store temperature in KELVIN for TELFIT\n            self.observation_info[name] = convert_temperature(\n                self.observation_info[name],\n                old_scale=\"Celsius\",\n                new_scale=\"Kelvin\",\n            )\n\n    if self.observation_info[\"relative_humidity\"] == 255:\n        logger.warning(f\"{self.name} has an invalid value in the humidity sensor...\")\n        self.observation_info[\"relative_humidity\"] = np.nan\n\n    self.observation_info[\"airmass\"] = header[\"HIERARCH ESO TEL AIRM START\"]\n</code></pre>"},{"location":"api/user_configs/","title":"Reference","text":"<p>Validators for the configuration options.</p> <p>We can combine multiple validation conditions by summing them, thus creating a AND condition</p> <p>Raises:</p> Type Description <code>InvalidConfiguration</code> <p>If passed value does not meet its imposed conditions</p> <code>InternalError</code> <p>Passing unknown configuration of the methods</p>"},{"location":"api/user_configs/#ASTRA.utils.parameter_validators.Constraint","title":"<code>Constraint</code>","text":"<p>Base class to define a constraint on possible values that a parameter can take.</p> <p>Serves as parent class, allows the \"sum\" of two constraints to make \"AND\" operations</p> <p>Attributes:</p> Name Type Description <code>constraint_text</code> <p>String that describes the constraint</p> <p>Raises:</p> Type Description <code>InvalidConfiguration</code> <p>If the constraint on the parameter value is not met</p> Source code in <code>src/ASTRA/utils/parameter_validators.py</code> <pre><code>class Constraint:\n    \"\"\"Base class to define a constraint on possible values that a parameter can take.\n\n    Serves as parent class, allows the \"sum\" of two constraints to make \"AND\" operations\n\n    Attributes:\n        constraint_text: String that describes the constraint\n\n    Raises:\n        InvalidConfiguration: If the constraint on the parameter value is not met\n\n    \"\"\"\n\n    def __init__(self, const_text: str):  # noqa: D107\n        self._constraint_list = [self._evaluate]\n        self.constraint_text = const_text\n\n    def __add__(self, other: Constraint) -&gt; Constraint:\n        \"\"\"Create AND condition of current and other.\"\"\"\n        new_const = Constraint(self.constraint_text)\n        # ensure that we don't propagate changes to all existing constraints\n        new_const._constraint_list = deepcopy(self._constraint_list)\n        new_const._constraint_list.append(other._evaluate)\n        new_const.constraint_text += \" and \" + other.constraint_text\n\n        return new_const\n\n    def __radd__(self, other: Constraint) -&gt; Constraint:  # noqa: D105\n        return self.__add__(other)\n\n    def _evaluate(self, value: Any) -&gt; None:\n        del value\n\n    def check_if_value_meets_constraint(self, value: Any) -&gt; None:\n        \"\"\"Compare the provided value against all constraint.\n\n        Args:\n            value (Any): Value to be compared\n\n        Raises:\n            InvalidConfiguration: If the value is not met\n\n        \"\"\"\n        for evaluator in self._constraint_list:\n            evaluator(value)\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return self.constraint_text\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return self.constraint_text\n\n    def __call__(self, value: Any) -&gt; None:\n        \"\"\"Call the self.check_if_value_meets_constraint.\"\"\"\n        self.check_if_value_meets_constraint(value)\n</code></pre>"},{"location":"api/user_configs/#ASTRA.utils.parameter_validators.Constraint.check_if_value_meets_constraint","title":"<code>check_if_value_meets_constraint(value)</code>","text":"<p>Compare the provided value against all constraint.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to be compared</p> required <p>Raises:</p> Type Description <code>InvalidConfiguration</code> <p>If the value is not met</p> Source code in <code>src/ASTRA/utils/parameter_validators.py</code> <pre><code>def check_if_value_meets_constraint(self, value: Any) -&gt; None:\n    \"\"\"Compare the provided value against all constraint.\n\n    Args:\n        value (Any): Value to be compared\n\n    Raises:\n        InvalidConfiguration: If the value is not met\n\n    \"\"\"\n    for evaluator in self._constraint_list:\n        evaluator(value)\n</code></pre>"},{"location":"api/user_configs/#ASTRA.utils.parameter_validators.IterableMustHave","title":"<code>IterableMustHave</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Imposes that certain values must be inside a given iterable.</p> Source code in <code>src/ASTRA/utils/parameter_validators.py</code> <pre><code>class IterableMustHave(Constraint):\n    \"\"\"Imposes that certain values must be inside a given iterable.\"\"\"\n\n    def __init__(self, available_options: tuple[Any, ...], mode: str = \"all\") -&gt; None:\n        \"\"\"Imposes that certain values must be inside the passed iterable object.\n\n        Args:\n            available_options (Tuple[Any]): Tuple with values that must be present in the iterable\n            mode (str, optional): \"all\" if we want all values present in the iterable,\n            \"any\" if we want at least one of them. Defaults to \"all\".\n\n        \"\"\"\n        super().__init__(const_text=f\"Must have value from list &lt;{available_options}&gt;\")\n        self.available_options = available_options\n        self.mode = mode\n\n        if mode not in [\"all\", \"any\"]:\n            msg = \"Using the wrong mode\"\n            raise InternalError(msg)\n\n    def _evaluate(self, value: Any) -&gt; None:\n        if not isinstance(value, Iterable):\n            msg = \"Constraint needs a iterable object\"\n            raise InvalidConfiguration(msg)\n\n        evaluation = [i in value for i in self.available_options]\n\n        good_value = False\n\n        if self.mode == \"all\":\n            good_value = all(evaluation)\n        elif self.mode == \"any\":\n            good_value = any(evaluation)\n\n        if not good_value:\n            raise InvalidConfiguration(\n                f\"Config value {value} does not\" \" have {self.mode} of {self.available_options}\",\n            )\n</code></pre>"},{"location":"api/user_configs/#ASTRA.utils.parameter_validators.PathExists","title":"<code>PathExists</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Imposes that a given path must exist.</p> Source code in <code>src/ASTRA/utils/parameter_validators.py</code> <pre><code>class PathExists(Constraint):\n    \"\"\"Imposes that a given path must exist.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Imposes that a given path exists.\"\"\"\n        super().__init__(const_text=\"The path must exist\")\n\n    def _evaluate(self, value: Any) -&gt; None:\n        if not Path(value).exists():\n            raise InvalidConfiguration(f\"Path {value} does not exist\")\n</code></pre>"},{"location":"api/user_configs/#ASTRA.utils.parameter_validators.ValueFromDtype","title":"<code>ValueFromDtype</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Constraint that limits the datatype of the input.</p> Source code in <code>src/ASTRA/utils/parameter_validators.py</code> <pre><code>class ValueFromDtype(Constraint):\n    \"\"\"Constraint that limits the datatype of the input.\"\"\"\n\n    def __init__(self, dtype_list: tuple[type, ...]) -&gt; None:\n        \"\"\"Constraint that limits the datatype of the input.\n\n        Args:\n            dtype_list (List[type]): Valid data types\n\n        \"\"\"\n        super().__init__(const_text=f\"Value from dtype &lt;{dtype_list}&gt;\")\n        self.valid_dtypes = dtype_list\n\n        if not isinstance(dtype_list, tuple):\n            msg = \"Dtype list must be a tuple\"\n            raise InternalError(msg)\n\n    def _evaluate(self, value: Any) -&gt; None:\n        if not isinstance(value, self.valid_dtypes):\n            msg = f\"Config value ({value}) not from\" f\"the valid dtypes: {type(value)} vs {self.valid_dtypes}\"\n            raise InvalidConfiguration(\n                msg,\n            )\n</code></pre>"},{"location":"api/user_configs/#ASTRA.utils.parameter_validators.ValueFromIterable","title":"<code>ValueFromIterable</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Limits the possible values to be inside a list.</p> Source code in <code>src/ASTRA/utils/parameter_validators.py</code> <pre><code>class ValueFromIterable(Constraint):\n    \"\"\"Limits the possible values to be inside a list.\"\"\"\n\n    def __init__(self, available_options: Iterable[Any]) -&gt; None:\n        \"\"\"Limits the possible values that the input can take.\n\n        Args:\n            available_options (Tuple[Any]): Tuple with the allowed values for this input\n\n        \"\"\"\n        super().__init__(const_text=f\"Value from list &lt;{available_options}&gt;\")\n        self.available_options = available_options\n        if not isinstance(available_options, Iterable):\n            msg = \"The available options must be an iterable\"\n            raise InternalError(msg)\n\n    def _evaluate(self, value: Any) -&gt; None:\n        bad_value = False\n        if isinstance(value, (list, tuple)):\n            for element in value:\n                if element not in self.available_options:\n                    bad_value = True\n                    break\n        elif isinstance(self.available_options, type) and not isinstance(\n            value,\n            self.available_options,\n        ):\n            # The value in Enum does not work properly before python3.12\n            bad_value = True\n        elif value not in self.available_options:\n            bad_value = True\n\n        if bad_value:\n            msg = f\"Config value not one of the valid ones: {value} vs {self.available_options}\"\n            raise InvalidConfiguration(\n                msg,\n            )\n</code></pre>"},{"location":"api/user_configs/#ASTRA.utils.parameter_validators.ValueInInterval","title":"<code>ValueInInterval</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Constraint that imposes the provided value to be inside a given interval.</p> Source code in <code>src/ASTRA/utils/parameter_validators.py</code> <pre><code>class ValueInInterval(Constraint):\n    \"\"\"Constraint that imposes the provided value to be inside a given interval.\"\"\"\n\n    def __init__(self, interval: tuple[Any, Any], include_edges: bool = False):\n        \"\"\"Instantiate the ValueInInterval class.\n\n        Args:\n            interval (Tuple): Tuple of the two edges of the interval\n            include_edges (bool, optional): Include the edge in the comparison.\n                Defaults to False.\n\n        \"\"\"\n        super().__init__(\n            const_text=f\"Value inside interval &lt;{interval}&gt;; Edges: {include_edges}\",\n        )\n        self._interval = interval\n        self._include_edges = include_edges\n\n    def _evaluate(self, value: Any) -&gt; None:\n        good_value = False\n        try:\n            if self._include_edges:\n                if self._interval[0] &lt;= value &lt;= self._interval[1]:\n                    good_value = True\n            elif self._interval[0] &lt; value &lt; self._interval[1]:\n                good_value = True\n        except TypeError as exc:\n            msg = f\"Config value can't be compared with the the interval: {value} ({type(value)}) vs {self._interval}\"\n            raise InvalidConfiguration(msg) from exc\n\n        if not good_value:\n            msg = f\"Config value is not inside the interval: {value} vs {self._interval}\"\n            raise InvalidConfiguration(msg)\n</code></pre>"},{"location":"spectra/","title":"Accessing stellar spectra","text":"<p>ASTRA provides an unyfying framework to interact with the stellar spectra of multiple state-of-the-art instruments. Its usage will ensure that our methods will be fully agnostic to the spectropgrah that we use, as they will all comply with the same API.</p> <pre><code>from ASTRA.data_objects.DataClass import DataClass\nfrom ASTRA.Instruments import ESPRESSO\n</code></pre> <p>The instruments sub-package provides with a mapping between a text-based name and ASTRA's class:</p> <pre><code>from ASTRA.Instruments import instrument_dict\n# instrument_dict = {\n#     \"ESPRESSO\": ESPRESSO,\n#     \"HARPS\": HARPS,\n# }\n</code></pre> <p>Internally, the entire ASTRA pipeline is built in such a way that it can process data from multiple \"time divisions\" of the same instrument individually. For example, it can recognize data from ESPRESSO18 and ESPRESSO19, creating individual stellar templates for each.</p>"},{"location":"spectra/access_spectra/","title":"Accessing stellar spectra","text":"In\u00a0[27]: Copied! <pre>from pathlib import Path\n\nfrom ASTRA.data_objects.DataClass import DataClass\nfrom ASTRA.Instruments import ESPRESSO\n\ninst_options = {}\n\ndata_in_path = list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\"))\ndata = DataClass(data_in_path, instrument=ESPRESSO, instrument_options=inst_options, storage_path=\"\")\n</pre> from pathlib import Path  from ASTRA.data_objects.DataClass import DataClass from ASTRA.Instruments import ESPRESSO  inst_options = {}  data_in_path = list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")) data = DataClass(data_in_path, instrument=ESPRESSO, instrument_options=inst_options, storage_path=\"\") <pre>2025-04-14 21:53:35.443 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of  - \n2025-04-14 21:53:35.444 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:53:35.445 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:53:35.446 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:53:35.447 | INFO     | ASTRA.data_objects.DataClass:__init__:126 - DataClass opening 3 files from a list/tuple\n2025-04-14 21:53:35.448 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-14 21:53:35.449 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:53:35.466 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:53:35.468 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -553975442344993652 rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-14 21:53:35.469 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-14T02:07:49.063_S2D_A.fits\n2025-04-14 21:53:35.471 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:53:35.488 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:53:35.490 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -2975062627551510774 rejected 15 orders for having SNR smaller than 5: 0-12, 32-33\n2025-04-14 21:53:35.492 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-20T01:43:40.032_S2D_A.fits\n2025-04-14 21:53:35.493 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:53:35.508 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:53:35.511 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame 3535164837059905149 rejected 16 orders for having SNR smaller than 5: 0-13, 32-33\n2025-04-14 21:53:35.513 | DEBUG    | ASTRA.data_objects.DataClass:__init__:154 - Selected 3 observations from disk\n2025-04-14 21:53:35.514 | INFO     | ASTRA.data_objects.DataClass:_collect_MetaData:369 - Collecting MetaData from the observations\n2025-04-14 21:53:35.515 | WARNING  | ASTRA.data_objects.Target:__init__:73 - Target dictionary not found in &lt;None&gt;\n2025-04-14 21:53:35.515 | DEBUG    | ASTRA.data_objects.Target:clean_targ_list:98 - Parsing through loaded OBJECTs\n2025-04-14 21:53:35.517 | INFO     | ASTRA.data_objects.Target:__init__:92 - Validated target to be V V645 Cen\n2025-04-14 21:53:35.517 | INFO     | ASTRA.data_objects.DataClass:show_loadedData_table:885 - --------------------------------------------------------------------\n--------------------------------------------------------------------\n  subInstrument    Total OBS    Valid OBS [warnings]   INVALID OBS   \n--------------------------------------------------------------------\n    ESPRESSO18         0               0 [0]                0        \n    ESPRESSO19         3               3 [0]                0        \n      Total            3               3 [0]                0        \n--------------------------------------------------------------------\n2025-04-14 21:53:35.518 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:894 - Checking if the instrument has extra data to load\n2025-04-14 21:53:35.519 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:901 - Current instrument does not need to load anything from the outside\n</pre> <p>In ASTRA, each observation is called a Frame, with a corresponding (unique) identifier (constructed from the hash of the filename, can take negative values). Furthermore, the division between multiple datasets of each instrument (known as sub-Instruments, e.g., ESPRESSO18, ESPRESSO19) is done automatically.</p> <p>Through the DataClass interface we can ask for:</p> <ol> <li>Data for a corresponding frameID</li> <li>Data for a given sub-Instrument</li> <li>All data that was loaded</li> </ol> <p>Furthermore, at runtime we can reject observations (either by user-imposed conditions or by internal QC checks).</p> In\u00a0[28]: Copied! <pre>from ASTRA.utils.spectral_conditions import FNAME_condition\n\nprint(data)\nprint(\"Loaded sub-Instruments\", data.get_subInstruments_with_valid_frames())\nprint(\"Current frameIDs\", data.get_valid_frameIDS())\nprint(\"Current (rejected) frameIDs\", data.get_invalid_frameIDs())\n\n\ncondition = FNAME_condition(data_in_path[0].name)\ndata.reject_observations(conditions=condition)\n\nprint(\"---//---\")\nprint(\"Current frameIDs\", data.get_valid_frameIDS())\nprint(\"Current (rejected) frameIDs\", data.get_invalid_frameIDs())\n</pre> from ASTRA.utils.spectral_conditions import FNAME_condition  print(data) print(\"Loaded sub-Instruments\", data.get_subInstruments_with_valid_frames()) print(\"Current frameIDs\", data.get_valid_frameIDS()) print(\"Current (rejected) frameIDs\", data.get_invalid_frameIDs())   condition = FNAME_condition(data_in_path[0].name) data.reject_observations(conditions=condition)  print(\"---//---\") print(\"Current frameIDs\", data.get_valid_frameIDS()) print(\"Current (rejected) frameIDs\", data.get_invalid_frameIDs())  <pre>2025-04-14 21:53:35.531 | DEBUG    | ASTRA.base_models.Frame:add_to_status:574 - Updating Frame (r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits) status to USER_BLOCKED: Filename rejected\n2025-04-14 21:53:35.532 | INFO     | ASTRA.data_objects.DataClass:reject_observations:292 - User conditions removed 1 / 3 frames\n2025-04-14 21:53:35.533 | INFO     | ASTRA.data_objects.DataClass:reject_observations:298 - Updated observation on disk!\n2025-04-14 21:53:35.534 | INFO     | ASTRA.data_objects.DataClass:show_loadedData_table:885 - --------------------------------------------------------------------\n--------------------------------------------------------------------\n  subInstrument    Total OBS    Valid OBS [warnings]   INVALID OBS   \n--------------------------------------------------------------------\n    ESPRESSO18         0               0 [0]                0        \n    ESPRESSO19         3               2 [0]                1        \n      Total            3               2 [0]                1        \n--------------------------------------------------------------------\n</pre> <pre>Data Class from &lt;class 'ASTRA.Instruments.ESPRESSO.ESPRESSO'&gt; holding 0 OBS from ESPRESSO18, 3 OBS from ESPRESSO19\nLoaded sub-Instruments ['ESPRESSO19']\nCurrent frameIDs [-553975442344993652, -2975062627551510774, 3535164837059905149]\nCurrent (rejected) frameIDs []\n---//---\nCurrent frameIDs [-2975062627551510774, 3535164837059905149]\nCurrent (rejected) frameIDs [-553975442344993652]\n</pre> In\u00a0[29]: Copied! <pre>available_subInstruments = data.get_subInstruments_with_valid_frames()\nccf_rv = data.collect_KW_observations(\"DRS_RV\", subInstruments=available_subInstruments)\n</pre> available_subInstruments = data.get_subInstruments_with_valid_frames() ccf_rv = data.collect_KW_observations(\"DRS_RV\", subInstruments=available_subInstruments) <p>Some of the internal values are stored as astropy.Quantity data products, which can be converted to float values through:</p> In\u00a0[30]: Copied! <pre>from ASTRA.utils.units import convert_data, kilometer_second\n\nconvert_data(data=ccf_rv, as_value=True, new_units= kilometer_second) \n</pre> from ASTRA.utils.units import convert_data, kilometer_second  convert_data(data=ccf_rv, as_value=True, new_units= kilometer_second)  Out[30]: <pre>[-21.3856633997537, -21.3845961288029]</pre> <p>In alternative, we can ask ASTRA to load the keywords directly from the header</p> In\u00a0[31]: Copied! <pre>data.collect_KW_observations(\"ESO QC CCF RV\", subInstruments=available_subInstruments, from_header=True)\n</pre> data.collect_KW_observations(\"ESO QC CCF RV\", subInstruments=available_subInstruments, from_header=True) Out[31]: <pre>[-21.3856633997537, -21.3845961288029]</pre> In\u00a0[37]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, axis = plt.subplots()\nfor frameID in data.get_valid_frameIDS():\n    wave, flux, err, mask = data.get_frame_OBS_order(frameID=frameID,\n                                                     order=50,\n                                                     )\n\n    good_pixel_mask = ~mask\n    axis.scatter(wave[good_pixel_mask], flux[good_pixel_mask], s=5)\naxis.set_xlabel(r\"wavelength $[\\AA]$\")\naxis.set_ylabel(\"Flux\")\n</pre> import matplotlib.pyplot as plt  fig, axis = plt.subplots() for frameID in data.get_valid_frameIDS():     wave, flux, err, mask = data.get_frame_OBS_order(frameID=frameID,                                                      order=50,                                                      )      good_pixel_mask = ~mask     axis.scatter(wave[good_pixel_mask], flux[good_pixel_mask], s=5) axis.set_xlabel(r\"wavelength $[\\AA]$\") axis.set_ylabel(\"Flux\")  Out[37]: <pre>Text(0, 0.5, 'Flux')</pre>"},{"location":"spectra/access_spectra/#accessing-stellar-spectra","title":"Accessing stellar spectra\u00b6","text":"<p>In the previous notebook we saw how to configure our DataClass to open ESPRESSO observations. In this, we will see how we can interact with the stellar spectra and the header keywords.</p>"},{"location":"spectra/access_spectra/#collect-header-keywords","title":"Collect header keywords\u00b6","text":"<p>By default, ASTRA collects some header keywords under a common name across multiple instruments, standardizing the information needed to construct the stellar template (see here for a full list). If needed, the collect_KW_observations also accepts a Condition object to select the observations from which we will load header information.</p> <p>Some values have an internal name that allows easy access:</p>"},{"location":"spectra/access_spectra/#accessing-stellar-spectra","title":"Accessing stellar spectra\u00b6","text":"<p>Through the DataClass interface we can directly access the wavelength, flux and uncertainties of the stellar spectra. Furthermore, we also gain access to a pixel-mask, containing the pixels that were rejected by the multiple processes</p>"},{"location":"spectra/open_spectra/","title":"Overview of the data flow in ASTRA","text":"In\u00a0[8]: Copied! <pre>from pathlib import Path \n\ndata_in_path = list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\"))\n</pre> from pathlib import Path   data_in_path = list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")) In\u00a0[9]: Copied! <pre>from ASTRA.Instruments import ESPRESSO\n\ninstrument = ESPRESSO\n\ninst_options = {\n    \"minimum_order_SNR\": 10,\n}\n</pre> from ASTRA.Instruments import ESPRESSO  instrument = ESPRESSO  inst_options = {     \"minimum_order_SNR\": 10, } In\u00a0[10]: Copied! <pre>from ASTRA.data_objects import DataClassManager\nfrom ASTRA.data_objects.DataClass import DataClass\n\nload_independent_process = False\n\nif load_independent_process:  # Option A)\n    manager = DataClassManager()\n    manager.start()\n    \n    # This makes available the same functions as the usual DataClass object\n    data: DataClass = manager.DataClass(data_in_path, instrument=ESPRESSO, instrument_options=inst_options, storage_path=\"\")\nelse:  # Option B)\n    data = DataClass(data_in_path, instrument=instrument, instrument_options=inst_options, storage_path=\"\")\n</pre> from ASTRA.data_objects import DataClassManager from ASTRA.data_objects.DataClass import DataClass  load_independent_process = False  if load_independent_process:  # Option A)     manager = DataClassManager()     manager.start()          # This makes available the same functions as the usual DataClass object     data: DataClass = manager.DataClass(data_in_path, instrument=ESPRESSO, instrument_options=inst_options, storage_path=\"\") else:  # Option B)     data = DataClass(data_in_path, instrument=instrument, instrument_options=inst_options, storage_path=\"\") <pre>2025-04-14 21:09:31.120 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of  - \n2025-04-14 21:09:31.123 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:09:31.124 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:09:31.126 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:09:31.126 | INFO     | ASTRA.data_objects.DataClass:__init__:126 - DataClass opening 3 files from a list/tuple\n2025-04-14 21:09:31.128 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-14 21:09:31.129 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:09:31.147 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:09:31.148 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame 9066568252996992604 rejected 48 orders for having SNR smaller than 10: 0-47\n2025-04-14 21:09:31.150 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-14T02:07:49.063_S2D_A.fits\n2025-04-14 21:09:31.151 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:09:31.167 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:09:31.170 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -2928113502234045974 rejected 38 orders for having SNR smaller than 10: 0-37\n2025-04-14 21:09:31.171 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-20T01:43:40.032_S2D_A.fits\n2025-04-14 21:09:31.173 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:09:31.190 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:09:31.193 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame 8549670138794176738 rejected 38 orders for having SNR smaller than 10: 0-37\n2025-04-14 21:09:31.195 | DEBUG    | ASTRA.data_objects.DataClass:__init__:154 - Selected 3 observations from disk\n2025-04-14 21:09:31.196 | INFO     | ASTRA.data_objects.DataClass:_collect_MetaData:369 - Collecting MetaData from the observations\n2025-04-14 21:09:31.197 | WARNING  | ASTRA.data_objects.Target:__init__:73 - Target dictionary not found in &lt;None&gt;\n2025-04-14 21:09:31.198 | DEBUG    | ASTRA.data_objects.Target:clean_targ_list:98 - Parsing through loaded OBJECTs\n2025-04-14 21:09:31.199 | INFO     | ASTRA.data_objects.Target:__init__:92 - Validated target to be V V645 Cen\n2025-04-14 21:09:31.199 | INFO     | ASTRA.data_objects.DataClass:show_loadedData_table:885 - --------------------------------------------------------------------\n--------------------------------------------------------------------\n  subInstrument    Total OBS    Valid OBS [warnings]   INVALID OBS   \n--------------------------------------------------------------------\n    ESPRESSO18         0               0 [0]                0        \n    ESPRESSO19         3               3 [0]                0        \n      Total            3               3 [0]                0        \n--------------------------------------------------------------------\n2025-04-14 21:09:31.200 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:894 - Checking if the instrument has extra data to load\n2025-04-14 21:09:31.201 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:901 - Current instrument does not need to load anything from the outside\n</pre> In\u00a0[5]: Copied! <pre>from ASTRA.Quality_Control.activity_indicators import Indicators\n\ninds = Indicators()\n</pre> from ASTRA.Quality_Control.activity_indicators import Indicators  inds = Indicators() In\u00a0[6]: Copied! <pre>inds.add_feature(name=\"feature_1\", region=[5000, 5500], vacuum_wavelengths=True)\n</pre> inds.add_feature(name=\"feature_1\", region=[5000, 5500], vacuum_wavelengths=True) In\u00a0[7]: Copied! <pre>data.remove_activity_lines(inds)\n</pre> data.remove_activity_lines(inds) <pre>2025-04-14 17:16:32.407 | INFO     | ASTRA.data_objects.DataClass:remove_activity_lines:216 - Computing activity windows for each RV measurements\n</pre>"},{"location":"spectra/open_spectra/#overview-of-the-data-flow-in-astra","title":"Overview of the data flow in ASTRA\u00b6","text":"<p>Goals of this notebook:</p> <ul> <li>Very brief explanation/overview of the basic user interface to load data from disk:<ul> <li>Load data from .fits files</li> <li>Configure the \"instrument\"</li> <li>Reject observations based on different conditions (e.g. HEADER values)</li> <li>Reject wavelength regions</li> </ul> </li> </ul>"},{"location":"spectra/open_spectra/#loading-data-from-disk","title":"Loading data from disk\u00b6","text":"<p>In this Section we look at how we can load spectral data from disk, which can be done in a general way through the DataClass object</p> <pre>from ASTRA.data_objects import DataClass\n</pre> <p>This object will ingest a list of observations, attribute them IDs (based on the hash of the filename) and divide them into different sub-Instruments. Furthermore, it will only open the spectra in memory when it is needed.</p>"},{"location":"spectra/open_spectra/#how-to-setup-our-instrument","title":"How to setup our instrument\u00b6","text":"<p>We can configure ASTRA to load files two different ways:</p> <ol> <li>Through a path to a file that contains (in each line) the full path to the desired fits file</li> <li>An iterable python object (e.g., a list, tuple) where each entry is the path to a fits file</li> </ol>"},{"location":"spectra/open_spectra/#selection-and-configuration-of-the-instrument","title":"Selection and configuration of the Instrument\u00b6","text":"<p>After generating the paths of the observations, the next step is to configure the instrument that we are using. The current version of ASTRA has two limitations:</p> <ol> <li>We can't mix data from multiple instruments in the same DataClass object</li> <li>It is not able to automatically determine the instrument associated with a given file.</li> </ol> <p>This means that the user must manually define the instrument that is in use. Then, similarly to all other ASTRA objects, we can configure multiple parameters to fine-tune the data pre-processing.</p>"},{"location":"spectra/open_spectra/#loading-the-data-from-disk","title":"Loading the data from disk\u00b6","text":"<p>There are two ways of loading the data from disk (that work in the same fashion):</p> <ul> <li>Load the data as an independent process (through DataClassManager)</li> <li>Load the data in the main python process (through DataClass)</li> </ul> <p>Note: Option A) makes use of python's proxy objects, serializing all communication. This means that we can use option A) to open all observation in one python core and share that data with multiple processes without re-opening data.</p>"},{"location":"spectra/open_spectra/#removing-activity-indicators-optional","title":"Removing activity indicators (Optional)\u00b6","text":"<ul> <li>ASTRA allows the rejection of specific wavelength intervals, that are known to be more sensitive to activity.</li> <li>By default, we remove lines that are typically used as activity indicators (on the optical domain, NIR is not yet included)</li> <li>This interface can also be used to manuall remove other wavelength regions, as long as it is configured to do so</li> </ul>"},{"location":"spectra/open_spectra/#removing-extra-regions","title":"Removing extra regions\u00b6","text":"<ul> <li>We must define a unique name (i.e. no repetitions, even among the default \"features\"</li> <li>We must define a region that will be removed from all observations that have been loaded from disk</li> <li>BY default we assume that the region is defined in air. Change to vacuum by passing vacuum_wavelength=True</li> </ul>"},{"location":"spectra/open_spectra/#applying-the-selected-region","title":"Applying the selected region\u00b6","text":"<p>Lastly, we have to ingest this object in our DataClass object, so that the rejected wavelengths are included in the spectral mask.</p>"},{"location":"spectra/selecting_spectra/","title":"Selecting Observations","text":""},{"location":"spectra/selecting_spectra/#selecting-observations","title":"Selecting Observations\u00b6","text":"<p>When using SBART we can reject observations in two different ways:</p> <ul> <li>globally - they are effectivelly discarded for all SBART operations</li> <li>temporarily -Only disable them for the creation of the Stellar Templates</li> </ul> <p>Even though the two rejection types have completely different effects, we always use the same format</p>"},{"location":"spectra/selecting_spectra/#based-on-header-values","title":"Based on Header values\u00b6","text":"<ul> <li>Allows to define bounds for the \"valid\" values that a given header value can take.</li> <li>The bounds argument takes a list of list, with each entry defining a \"region\" that the value can take.</li> <li>If we want to place no upper/lower limits, we can place a None</li> </ul> <pre>    # Only use observations that can have AIRMASS smaller than 1.5 or larger than 1.6\n    valid_AIRM_condition = KEYWORD_condition(KW = \"airmass\",\n                                          bounds=[[None, 1.5], [1.6, None]]\n                                         )\n\n    # Only select observations that have a previous RV error (the one from the CCF) smaller than 50 meter_second\n    # Note1: the conditions for 'RV related' values (previousRV, drift, BERV) must be in meter_second OR kilometer_second\n    # Note2: the units will be converted later on, so either \"unit\" can be chosen\n\n    valid_error_condition = KEYWORD_condition(KW=\"previousRV_ERR\",\n                                              bounds = [0, 50*meter_second])\n</pre>"},{"location":"spectra/selecting_spectra/#rejection-based-on-filenames","title":"Rejection based on filenames\u00b6","text":"<p>Provide a list of bad filenames that will be rejected.</p> <p>Note: Filename only, do NOT pass a path</p> <pre>    bad_filename_condition = FNAME_condition(filename_list=[\"filename.fits\"])\n</pre>"},{"location":"spectra/selecting_spectra/#rejecting-based-on-the-subinstrument","title":"Rejecting based on the \"subInstrument\"\u00b6","text":"<p>Reject all observations from ESPRESSO21</p> <pre>    bad_subInst_condition = SubInstrument_condition(\"ESPRESSO21\")\n</pre>"},{"location":"spectra/selecting_spectra/#rejecting-based-on-warning-flags","title":"Rejecting based on Warning Flags\u00b6","text":"<p>Reject observation if a given warning flag was set when loading the spectra</p> <pre>    bad_subInst_condition = WarningFlag_Notset(\"HIERARCH ESO QC SCIRED DRIFT CHECK\")\n</pre>"},{"location":"spectra/selecting_spectra/#combining-conditions","title":"Combining conditions\u00b6","text":"<p>To combine multiple conditions, sum them together. The observations will be rejected if any Condition decides to reject it</p> <pre>    full_conditions = valid_AIRM_condition + valid_error_condition + bad_filename_condition + bad_subInst_condition\n</pre>"},{"location":"spectra/selecting_spectra/#applying-the-conditions","title":"Applying the conditions\u00b6","text":"<p>For a DataClass  object, we can use its reject_observations method</p> <pre>    data.reject_observations(full_conditions)\n</pre> <p>Otherwise, other data-aggregation methods usually allow to provide a condition model to help specify the observations of interest.</p>"},{"location":"template_creation/","title":"Template creation","text":"<p>In ASTRA, the interface to generate stellar and telluric templates is quite similar. Both support the same API functions, albeit to different goals. In short, they provide us with:</p> <p>1) Internal storage and load from disk files (for re-utilization purposes)</p> <p>2) Common interface to access wavelength and \"fluxes\"/masks of the templates </p> <p>Internally, they are constructed individually for each sub-Instrument that we have available to us.</p> <p>The templates will be constructed and automatically saved to disk, under the specified disk path. If ASTRA finds a pre-existing template in that storage path, it will instead load the previous template to memory (unless it is forced to construct a new one). </p>"},{"location":"template_creation/stellar/","title":"Construction of stellar templates","text":"In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n\nfrom ASTRA.data_objects import DataClassManager\nfrom ASTRA.data_objects.DataClass import DataClass\nfrom ASTRA.Instruments import ESPRESSO\nfrom ASTRA.template_creation.StellarModel import StellarModel\n\nstorage_path = Path(\"../../tmp\")\nmanager = DataClassManager()\nmanager.start()\n\nd: DataClass = manager.DataClass(\n    list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")),\n    storage_path=storage_path,\n    instrument=ESPRESSO,\n)\n\nstell = StellarModel(\n    storage_path,\n    user_configs={},\n    \n)\nstell.Generate_Model(\n    dataClass=d,\n    template_configs={},\n    force_computation=True,\n)\n</pre>  from pathlib import Path  from ASTRA.data_objects import DataClassManager from ASTRA.data_objects.DataClass import DataClass from ASTRA.Instruments import ESPRESSO from ASTRA.template_creation.StellarModel import StellarModel  storage_path = Path(\"../../tmp\") manager = DataClassManager() manager.start()  d: DataClass = manager.DataClass(     list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")),     storage_path=storage_path,     instrument=ESPRESSO, )  stell = StellarModel(     storage_path,     user_configs={},      ) stell.Generate_Model(     dataClass=d,     template_configs={},     force_computation=True, )   <pre>2025-04-15 14:56:41.420 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of  - \n2025-04-15 14:56:41.424 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 14:56:41.426 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 14:56:41.428 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 14:56:41.432 | INFO     | ASTRA.data_objects.DataClass:__init__:126 - DataClass opening 3 files from a list/tuple\n2025-04-15 14:56:41.434 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-15 14:56:41.436 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-15 14:56:41.458 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 14:56:41.462 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame -3539887270512102415 rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-15 14:56:41.582 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-14T02:07:49.063_S2D_A.fits\n2025-04-15 14:56:41.585 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-15 14:56:41.846 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 14:56:41.850 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame -6655143944787757955 rejected 15 orders for having SNR smaller than 5: 0-12, 32-33\n2025-04-15 14:56:41.852 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-20T01:43:40.032_S2D_A.fits\n2025-04-15 14:56:41.854 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-15 14:56:41.871 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 14:56:41.874 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame 7020571171304516718 rejected 16 orders for having SNR smaller than 5: 0-13, 32-33\n2025-04-15 14:56:41.876 | DEBUG    | ASTRA.data_objects.DataClass:__init__:154 - Selected 3 observations from disk\n2025-04-15 14:56:41.878 | INFO     | ASTRA.data_objects.DataClass:_collect_MetaData:369 - Collecting MetaData from the observations\n2025-04-15 14:56:41.880 | WARNING  | ASTRA.data_objects.Target:__init__:73 - Target dictionary not found in &lt;None&gt;\n2025-04-15 14:56:41.881 | DEBUG    | ASTRA.data_objects.Target:clean_targ_list:98 - Parsing through loaded OBJECTs\n2025-04-15 14:56:41.883 | INFO     | ASTRA.data_objects.Target:__init__:92 - Validated target to be V V645 Cen\n2025-04-15 14:56:41.885 | INFO     | ASTRA.data_objects.DataClass:show_loadedData_table:885 - --------------------------------------------------------------------\n--------------------------------------------------------------------\n  subInstrument    Total OBS    Valid OBS [warnings]   INVALID OBS   \n--------------------------------------------------------------------\n    ESPRESSO18         0               0 [0]                0        \n    ESPRESSO19         3               3 [0]                0        \n      Total            3               3 [0]                0        \n--------------------------------------------------------------------\n2025-04-15 14:56:41.887 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:894 - Checking if the instrument has extra data to load\n2025-04-15 14:56:41.888 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:901 - Current instrument does not need to load anything from the outside\n2025-04-15 14:56:41.897 | INFO     | ASTRA.base_models.TemplateFramework:__init__:72 - Starting Stellar Model\n2025-04-15 14:56:41.899 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of SpectralModel - Stellar\n2025-04-15 14:56:41.901 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 14:56:41.903 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 14:56:41.904 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 14:56:41.904 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;CREATION_MODE&gt; using the default value: STELLAR_CREATION_MODE.Sum\n2025-04-15 14:56:41.905 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;ALIGNEMENT_RV_SOURCE&gt; using the default value: DRS\n2025-04-15 14:56:41.906 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;PREVIOUS_SBART_PATH&gt; using the default value: \n2025-04-15 14:56:41.907 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;USE_MERGED_RVS&gt; using the default value: False\n2025-04-15 14:56:41.909 | INFO     | ASTRA.template_creation.StellarModel:Generate_Model:165 - Using CCF RVs as the basis for the creation of the stellar models\n2025-04-15 14:56:41.910 | DEBUG    | ASTRA.base_models.TemplateFramework:Generate_Model:138 - Starting the creation of Stellar models!\n2025-04-15 14:56:41.910 | INFO     | ASTRA.base_models.TemplateFramework:Generate_Model:147 - Creating all templates from scratch\n2025-04-15 14:56:41.911 | DEBUG    | ASTRA.utils.UserConfigs:update_configs_with_values:198 - Configuration &lt;WORKING_MODE&gt; taking the value: WORKING_MODE.ONE_SHOT\n2025-04-15 14:56:41.914 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of Sum-Stellar from ESPRESSO18\n2025-04-15 14:56:41.915 | DEBUG    | ASTRA.utils.UserConfigs:update_configs_with_values:198 - Configuration &lt;ALIGNEMENT_RV_SOURCE&gt; taking the value: DRS\n2025-04-15 14:56:41.916 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 14:56:41.917 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 14:56:41.917 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 14:56:41.918 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;CONSTANT_RV_GUESS&gt; using the default value: False\n2025-04-15 14:56:41.918 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;NUMBER_WORKERS&gt; using the default value: 1\n2025-04-15 14:56:41.919 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MEMORY_SAVE_MODE&gt; using the default value: False\n2025-04-15 14:56:41.920 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MINIMUM_NUMBER_OBS&gt; using the default value: 3\n2025-04-15 14:56:41.920 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_threshold_for_template&gt; using the default value: 1\n2025-04-15 14:56:41.921 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOL_MODE&gt; using the default value: SPECTRA_INTERPOL_MODE.SPLINES\n2025-04-15 14:56:41.922 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SPLINE_TYPE&gt; using the default value: SPLINE_INTERPOL_MODE.CUBIC_SPLINE\n2025-04-15 14:56:41.923 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOLATION_ERR_PROP&gt; using the default value: INTERPOLATION_ERR_PROP.interpolation\n2025-04-15 14:56:41.923 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_CONFIGS&gt; using the default value: FLUX_SMOOTH_CONFIGS.NONE\n2025-04-15 14:56:41.924 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_WINDOW_SIZE&gt; using the default value: 15\n2025-04-15 14:56:41.925 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_DEG&gt; using the default value: 2\n2025-04-15 14:56:41.925 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_ORDER&gt; using the default value: FLUX_SMOOTH_ORDER.AFTER\n2025-04-15 14:56:41.926 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Sum-Stellar from ESPRESSO18\n2025-04-15 14:56:41.927 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:132 - Starting creation of Stellar template from ESPRESSO18\n2025-04-15 14:56:41.929 | CRITICAL | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:144 - ESPRESSO18 has no valid observations. Not computing Stellar template\n2025-04-15 14:56:41.930 | WARNING  | ASTRA.base_models.Template_Model:_base_checks_for_template_creation:102 - Template will not be created. Check previous error messages\n2025-04-15 14:56:41.931 | WARNING  | ASTRA.template_creation.StellarModel:_compute_template:197 - Key &lt;ALIGNEMENT_RV_SOURCE&gt; from Stellar Model over-riding the one from the template configs\n2025-04-15 14:56:41.931 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of Sum-Stellar from ESPRESSO19\n2025-04-15 14:56:41.933 | DEBUG    | ASTRA.utils.UserConfigs:update_configs_with_values:198 - Configuration &lt;ALIGNEMENT_RV_SOURCE&gt; taking the value: DRS\n2025-04-15 14:56:41.934 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 14:56:41.934 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 14:56:41.935 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 14:56:41.935 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;CONSTANT_RV_GUESS&gt; using the default value: False\n2025-04-15 14:56:41.935 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;NUMBER_WORKERS&gt; using the default value: 1\n2025-04-15 14:56:41.936 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MEMORY_SAVE_MODE&gt; using the default value: False\n2025-04-15 14:56:41.936 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MINIMUM_NUMBER_OBS&gt; using the default value: 3\n2025-04-15 14:56:41.936 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_threshold_for_template&gt; using the default value: 1\n2025-04-15 14:56:41.937 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOL_MODE&gt; using the default value: SPECTRA_INTERPOL_MODE.SPLINES\n2025-04-15 14:56:41.938 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SPLINE_TYPE&gt; using the default value: SPLINE_INTERPOL_MODE.CUBIC_SPLINE\n2025-04-15 14:56:41.938 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOLATION_ERR_PROP&gt; using the default value: INTERPOLATION_ERR_PROP.interpolation\n2025-04-15 14:56:41.938 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_CONFIGS&gt; using the default value: FLUX_SMOOTH_CONFIGS.NONE\n2025-04-15 14:56:41.939 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_WINDOW_SIZE&gt; using the default value: 15\n2025-04-15 14:56:41.939 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_DEG&gt; using the default value: 2\n2025-04-15 14:56:41.940 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_ORDER&gt; using the default value: FLUX_SMOOTH_ORDER.AFTER\n2025-04-15 14:56:41.940 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Sum-Stellar from ESPRESSO19\n2025-04-15 14:56:41.941 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:132 - Starting creation of Stellar template from ESPRESSO19\n2025-04-15 14:56:41.943 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:162 - Evaluating spectral conditions to select the valid observations from ESPRESSO19\n2025-04-15 14:56:41.959 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:861 - Opening the S2D arrays from r.ESPRE.2019-07-20T01:43:40.032_S2D_A.fits\n2025-04-15 14:56:41.990 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-15 14:56:42.070 | DEBUG    | ASTRA.base_models.Frame:build_mask:627 - Cleaning wavelength regions from []\n2025-04-15 14:56:42.073 | DEBUG    | ASTRA.base_models.Frame:build_mask:645 - Removed 0 regions ()\n2025-04-15 14:56:42.076 | DEBUG    | ASTRA.base_models.Frame:build_mask:671 - Ensuring that we have increasing wavelengths\n2025-04-15 14:56:42.093 | DEBUG    | ASTRA.base_models.Frame:build_mask:677 - Took 0 seconds ()\n2025-04-15 14:56:42.097 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 14:56:42.123 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:723 - Frame 7020571171304516718 rejected 16 orders due for having less than 0.25 valid pixels: 0-13, 32-33\n2025-04-15 14:56:42.126 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame 7020571171304516718 rejected 16 orders for having SNR smaller than 5: 0-13, 32-33\n2025-04-15 14:56:42.507 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:140 - Using observation from Frame of ESPRESSO : ESPRESSO19 data (2019-07-20T01:43:40.031; ID = 7020571171304516718) as a basis for stellar template construction\n2025-04-15 14:56:42.511 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:145 - Using frameIDs: [-3539887270512102415, -6655143944787757955, 7020571171304516718]\n2025-04-15 14:56:42.512 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:157 - Launching 1 workers!\n2025-04-15 14:56:42.512 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:convert_to_shared_mem:553 - Putting the stellar template in shared memory\n2025-04-15 14:56:42.573 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:861 - Opening the S2D arrays from r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-15 14:56:42.609 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-15 14:56:42.688 | DEBUG    | ASTRA.base_models.Frame:build_mask:627 - Cleaning wavelength regions from []\n2025-04-15 14:56:42.690 | DEBUG    | ASTRA.base_models.Frame:build_mask:645 - Removed 0 regions ()\n2025-04-15 14:56:42.692 | DEBUG    | ASTRA.base_models.Frame:build_mask:671 - Ensuring that we have increasing wavelengths\n2025-04-15 14:56:42.711 | DEBUG    | ASTRA.base_models.Frame:build_mask:677 - Took 0 seconds ()\n2025-04-15 14:56:42.714 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 14:56:42.740 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:723 - Frame -3539887270512102415 rejected 37 orders due for having less than 0.25 valid pixels: 0-36\n2025-04-15 14:56:42.744 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame -3539887270512102415 rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-15 14:56:43.650 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:861 - Opening the S2D arrays from r.ESPRE.2019-07-14T02:07:49.063_S2D_A.fits\n2025-04-15 14:56:43.675 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-15 14:56:43.754 | DEBUG    | ASTRA.base_models.Frame:build_mask:627 - Cleaning wavelength regions from []\n2025-04-15 14:56:43.757 | DEBUG    | ASTRA.base_models.Frame:build_mask:645 - Removed 0 regions ()\n2025-04-15 14:56:43.758 | DEBUG    | ASTRA.base_models.Frame:build_mask:671 - Ensuring that we have increasing wavelengths\n2025-04-15 14:56:43.774 | DEBUG    | ASTRA.base_models.Frame:build_mask:677 - Took 0 seconds ()\n2025-04-15 14:56:43.777 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 14:56:43.801 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:723 - Frame -6655143944787757955 rejected 15 orders due for having less than 0.25 valid pixels: 0-12, 32-33\n2025-04-15 14:56:43.804 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame -6655143944787757955 rejected 15 orders for having SNR smaller than 5: 0-12, 32-33\n2025-04-15 14:56:45.808 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:217 - Updating template mask\n2025-04-15 14:56:45.849 | DEBUG    | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:226 - Ensuring increasing wavelenghs in the stellar template\n2025-04-15 14:56:45.869 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:239 - Construction of stellar template took 3.297156572341919\n2025-04-15 14:56:45.871 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 0 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.872 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 1 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.873 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 2 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.874 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 3 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.875 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 4 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.876 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 5 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.877 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 6 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.878 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 7 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.879 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 8 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.880 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 9 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.881 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 10 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.882 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 11 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.882 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 12 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.883 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 13 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.884 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 14 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.886 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 15 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.887 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 16 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.888 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 17 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.889 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 18 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.889 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 19 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.891 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 20 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.892 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 21 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.894 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 22 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.895 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 23 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.895 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 24 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.896 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 25 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.896 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 26 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.897 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 27 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.897 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 28 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.898 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 29 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.898 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 30 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.899 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 31 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.900 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 32 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.900 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 33 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.900 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 34 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.901 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 35 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.901 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 36 due to having more than 9011/9111 pixels masked\n2025-04-15 14:56:45.903 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:create_stellar_template:103 - Closing shared memory interfaces of the Stellar template\n2025-04-15 14:56:45.904 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:cleanup_shared_memory:578 - Cleaning the shared memory interfaces from the Stellar template creation\n2025-04-15 14:56:45.905 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:_close_workers:584 - Sum-Stellar from ESPRESSO19 closing the workers\n2025-04-15 14:56:45.907 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:_close_queues:601 - Sum-Stellar from ESPRESSO19 closing the communication queues\n2025-04-15 14:56:45.910 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:_close_shared_memory_arrays:590 - Sum-Stellar from ESPRESSO19 closing the shared memory array\n2025-04-15 14:56:45.913 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:277 - Storing templates from &lt;Stellar&gt; under the directory\n2025-04-15 14:56:45.914 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:281 - \t../../tmp/templates/Stellar/Iteration_0\n2025-04-15 14:56:45.915 | INFO     | ASTRA.base_models.Template_Model:trigger_data_storage:95 - The template from ESPRESSO18 was not created. Storing nothing to disk\n2025-04-15 14:56:45.915 | INFO     | ASTRA.base_models.Template_Model:store_template:119 - Storing Sum-Stellar from ESPRESSO19 to disk\n2025-04-15 14:56:45.916 | WARNING  | ASTRA.base_models.Template_Model:store_template:135 - Disabled removal of old disk files!\n2025-04-15 14:56:45.992 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:store_template:414 - Storing used filepaths to disk\n2025-04-15 14:56:45.994 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:_store_json_information:331 - Storing template flags to disk\n</pre> In\u00a0[4]: Copied! <pre>stellar_template = stell.request_data(\"ESPRESSO19\")\n</pre> stellar_template = stell.request_data(\"ESPRESSO19\") <p>This stellar_template object will have the same spectra-interfacing as the Frames:</p> In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, axis = plt.subplots()\nwave, flux, err, mask = stellar_template.get_data_from_spectral_order(order=50)\ngood_pixel_mask = ~mask\naxis.scatter(wave[good_pixel_mask], flux[good_pixel_mask], s=5)\naxis.set_xlabel(r\"wavelength $[\\AA]$\")\naxis.set_ylabel(\"Flux\")\n</pre> import matplotlib.pyplot as plt  fig, axis = plt.subplots() wave, flux, err, mask = stellar_template.get_data_from_spectral_order(order=50) good_pixel_mask = ~mask axis.scatter(wave[good_pixel_mask], flux[good_pixel_mask], s=5) axis.set_xlabel(r\"wavelength $[\\AA]$\") axis.set_ylabel(\"Flux\")  Out[6]: <pre>Text(0, 0.5, 'Flux')</pre>"},{"location":"template_creation/stellar/#construction-of-stellar-templates","title":"Construction of stellar templates\u00b6","text":"<p>The construction of Stellar templates is handled through the StellarModel interface, which will create independent stellar templates for each sub-Instrument that we have available in the DataClass. The construction of the stellar templates follows the framework described in Silva et al, 2022, and is shematized in here:</p> <p></p>"},{"location":"template_creation/stellar/#accessing-the-templates","title":"Accessing the templates\u00b6","text":"<p>After construction of the Stellar template, we can access them independently for each sub-Instrument:</p>"},{"location":"template_creation/telluric/","title":"Telluric Models","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nfrom ASTRA.data_objects import DataClassManager\nfrom ASTRA.data_objects.DataClass import DataClass\nfrom ASTRA.Instruments import ESPRESSO\nfrom ASTRA.template_creation.TelluricModel import TelluricModel\nfrom ASTRA.utils.choices import TELLURIC_CREATION_MODE, TELLURIC_EXTENSION\n\nstorage_path = Path(\"../../tmp\")\nmanager = DataClassManager()\nmanager.start()\n\ndata: DataClass = manager.DataClass(\n    list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")),\n    storage_path=storage_path,\n    instrument=ESPRESSO,\n)\n\nModelTell = TelluricModel(\n    usage_mode=\"individual\",\n    user_configs={\"CREATION_MODE\": TELLURIC_CREATION_MODE.telfit,\n                  \"EXTENSION_MODE\": TELLURIC_EXTENSION.LINES},\n    root_folder_path=storage_path,\n)\n\nModelTell.Generate_Model(\n    dataClass=data,\n    telluric_configs={\"continuum_percentage_drop\": 1},\n    force_computation=False,\n    store_templates=True,\n)\n</pre> from pathlib import Path  from ASTRA.data_objects import DataClassManager from ASTRA.data_objects.DataClass import DataClass from ASTRA.Instruments import ESPRESSO from ASTRA.template_creation.TelluricModel import TelluricModel from ASTRA.utils.choices import TELLURIC_CREATION_MODE, TELLURIC_EXTENSION  storage_path = Path(\"../../tmp\") manager = DataClassManager() manager.start()  data: DataClass = manager.DataClass(     list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")),     storage_path=storage_path,     instrument=ESPRESSO, )  ModelTell = TelluricModel(     usage_mode=\"individual\",     user_configs={\"CREATION_MODE\": TELLURIC_CREATION_MODE.telfit,                   \"EXTENSION_MODE\": TELLURIC_EXTENSION.LINES},     root_folder_path=storage_path, )  ModelTell.Generate_Model(     dataClass=data,     telluric_configs={\"continuum_percentage_drop\": 1},     force_computation=False,     store_templates=True, )  <pre>2025-04-15 15:23:44.309 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of  - \n2025-04-15 15:23:44.314 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 15:23:44.316 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 15:23:44.318 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 15:23:44.322 | INFO     | ASTRA.data_objects.DataClass:__init__:126 - DataClass opening 3 files from a list/tuple\n2025-04-15 15:23:44.324 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-15 15:23:44.327 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-15 15:23:44.351 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 15:23:44.357 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame 9211860738973677165 rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-15 15:23:44.752 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-14T02:07:49.063_S2D_A.fits\n2025-04-15 15:23:44.754 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-15 15:23:44.777 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 15:23:44.780 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame -2338102534959840306 rejected 15 orders for having SNR smaller than 5: 0-12, 32-33\n2025-04-15 15:23:44.783 | INFO     | ASTRA.base_models.Frame:__init__:252 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-20T01:43:40.032_S2D_A.fits\n2025-04-15 15:23:44.785 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-15 15:23:44.801 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:710 - Rejecting spectral orders\n2025-04-15 15:23:44.804 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:740 - Frame -8700540904792705412 rejected 16 orders for having SNR smaller than 5: 0-13, 32-33\n2025-04-15 15:23:44.807 | DEBUG    | ASTRA.data_objects.DataClass:__init__:154 - Selected 3 observations from disk\n2025-04-15 15:23:44.809 | INFO     | ASTRA.data_objects.DataClass:_collect_MetaData:369 - Collecting MetaData from the observations\n2025-04-15 15:23:44.811 | WARNING  | ASTRA.data_objects.Target:__init__:73 - Target dictionary not found in &lt;None&gt;\n2025-04-15 15:23:44.813 | DEBUG    | ASTRA.data_objects.Target:clean_targ_list:98 - Parsing through loaded OBJECTs\n2025-04-15 15:23:44.815 | INFO     | ASTRA.data_objects.Target:__init__:92 - Validated target to be V V645 Cen\n2025-04-15 15:23:44.817 | INFO     | ASTRA.data_objects.DataClass:show_loadedData_table:885 - --------------------------------------------------------------------\n--------------------------------------------------------------------\n  subInstrument    Total OBS    Valid OBS [warnings]   INVALID OBS   \n--------------------------------------------------------------------\n    ESPRESSO18         0               0 [0]                0        \n    ESPRESSO19         3               3 [0]                0        \n      Total            3               3 [0]                0        \n--------------------------------------------------------------------\n2025-04-15 15:23:44.819 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:894 - Checking if the instrument has extra data to load\n2025-04-15 15:23:44.821 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:901 - Current instrument does not need to load anything from the outside\n2025-04-15 15:23:44.830 | INFO     | ASTRA.base_models.TemplateFramework:__init__:72 - Starting Telluric Model\n2025-04-15 15:23:44.832 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of BASE - TemplateFramework\n2025-04-15 15:23:44.834 | DEBUG    | ASTRA.utils.UserConfigs:update_configs_with_values:198 - Configuration &lt;CREATION_MODE&gt; taking the value: TELLURIC_CREATION_MODE.telfit\n2025-04-15 15:23:44.835 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 15:23:44.836 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 15:23:44.837 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 15:23:44.839 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;APPLICATION_MODE&gt; using the default value: TELLURIC_APPLICATION_MODE.removal\n2025-04-15 15:23:44.840 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;EXTENSION_MODE&gt; using the default value: TELLURIC_EXTENSION.LINES\n2025-04-15 15:23:44.845 | INFO     | ASTRA.template_creation.TelluricModel:__init__:91 - Starting Telluric Model\n2025-04-15 15:23:44.847 | DEBUG    | ASTRA.base_models.TemplateFramework:Generate_Model:138 - Starting the creation of Telluric models!\n2025-04-15 15:23:44.848 | INFO     | ASTRA.base_models.TemplateFramework:Generate_Model:141 - Attempting to load previous Templates from disk before creating them\n2025-04-15 15:23:44.850 | DEBUG    | ASTRA.base_models.TemplateFramework:load_templates_from_disk:178 - Searching in : ../../tmp/templates/Telluric for TELLURIC_CREATION_MODE.telfit\n2025-04-15 15:23:44.852 | INFO     | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:180 - Loading Telluric template from disk inside directory\n2025-04-15 15:23:44.853 | INFO     | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:181 - \t../../tmp/templates/Telluric\n2025-04-15 15:23:44.855 | INFO     | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:192 - Found 0 available templates: [] of type TELLURIC_CREATION_MODE.telfit\n2025-04-15 15:23:44.856 | CRITICAL | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:199 - Could not find templates to load!\n2025-04-15 15:23:44.857 | INFO     | ASTRA.base_models.TemplateFramework:Generate_Model:145 - No templates to load from disk. Creating all from scratch\n2025-04-15 15:23:44.861 | INFO     | ASTRA.template_creation.TelluricModel:_compute_template:205 - Using template of type: TELLURIC_CREATION_MODE.telfit\n2025-04-15 15:23:44.863 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of telfit-Telluric from ESPRESSO18\n2025-04-15 15:23:44.864 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 15:23:44.865 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 15:23:44.867 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 15:23:44.868 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;continuum_percentage_drop&gt; using the default value: 1\n2025-04-15 15:23:44.870 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;force_download&gt; using the default value: False\n2025-04-15 15:23:44.871 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;inverse_mask&gt; using the default value: False\n2025-04-15 15:23:44.872 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;atmosphere_profile&gt; using the default value: GDAS\n2025-04-15 15:23:44.873 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_MODEL&gt; using the default value: False\n2025-04-15 15:23:44.874 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;TELFIT_HUMIDITY_THRESHOLD&gt; using the default value: -1\n2025-04-15 15:23:44.875 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_WAVELENGTH_STEP_SIZE&gt; using the default value: 0.001\n2025-04-15 15:23:44.876 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;PARAMS_TO_FIT&gt; using the default value: ['pressure', 'humidity']\n2025-04-15 15:23:44.876 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;USE_GRID_OF_TRANSMITTANCE&gt; using the default value: False\n2025-04-15 15:23:44.877 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;GRID_MAIN_PATH&gt; using the default value: None\n2025-04-15 15:23:44.877 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;IND_WATER_MASK_THRESHOLD&gt; using the default value: 100000000.0\n2025-04-15 15:23:44.878 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of telfit-Telluric from ESPRESSO18\n2025-04-15 15:23:44.879 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:load_information_from_DataClass:166 - Template telfit-Telluric from ESPRESSO18 loading data from the dataClass\n2025-04-15 15:23:44.881 | WARNING  | ASTRA.template_creation.telluric_templates.Telluric_Template:_load_BERV_info:200 - ESPRESSO18 has no valid observations. Not computing telluric template\n2025-04-15 15:23:44.886 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:create_telluric_template:313 - Starting creation of Telluric template from ESPRESSO18\n2025-04-15 15:23:44.887 | WARNING  | ASTRA.template_creation.telluric_templates.Telluric_Template:_search_reference_frame:256 - ESPRESSO18 has no valid observations. Not computing telluric template\n2025-04-15 15:23:44.888 | WARNING  | ASTRA.base_models.Template_Model:_base_checks_for_template_creation:102 - Template will not be created. Check previous error messages\n2025-04-15 15:23:44.890 | INFO     | ASTRA.template_creation.TelluricModel:_compute_template:205 - Using template of type: TELLURIC_CREATION_MODE.telfit\n2025-04-15 15:23:44.891 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of telfit-Telluric from ESPRESSO19\n2025-04-15 15:23:44.892 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-15 15:23:44.894 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-15 15:23:44.895 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-15 15:23:44.895 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;continuum_percentage_drop&gt; using the default value: 1\n2025-04-15 15:23:44.897 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;force_download&gt; using the default value: False\n2025-04-15 15:23:44.898 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;inverse_mask&gt; using the default value: False\n2025-04-15 15:23:44.899 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;atmosphere_profile&gt; using the default value: GDAS\n2025-04-15 15:23:44.900 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_MODEL&gt; using the default value: False\n2025-04-15 15:23:44.901 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;TELFIT_HUMIDITY_THRESHOLD&gt; using the default value: -1\n2025-04-15 15:23:44.902 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_WAVELENGTH_STEP_SIZE&gt; using the default value: 0.001\n2025-04-15 15:23:44.903 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;PARAMS_TO_FIT&gt; using the default value: ['pressure', 'humidity']\n2025-04-15 15:23:44.907 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;USE_GRID_OF_TRANSMITTANCE&gt; using the default value: False\n2025-04-15 15:23:44.909 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;GRID_MAIN_PATH&gt; using the default value: None\n2025-04-15 15:23:44.910 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;IND_WATER_MASK_THRESHOLD&gt; using the default value: 100000000.0\n2025-04-15 15:23:44.911 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of telfit-Telluric from ESPRESSO19\n2025-04-15 15:23:44.913 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:load_information_from_DataClass:166 - Template telfit-Telluric from ESPRESSO19 loading data from the dataClass\n2025-04-15 15:23:44.924 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:_generate_model_parameters:150 - Generating the parameters of the model applied in telfit-Telluric from ESPRESSO19\n2025-04-15 15:23:44.925 | INFO     | ASTRA.ModelParameters.Model:generate_priors:20 - Generating priors of the model' parameters\n2025-04-15 15:23:45.246 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting temperature. Fixing it to initial guess\n2025-04-15 15:23:45.248 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting co2. Fixing it to initial guess\n2025-04-15 15:23:45.249 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting ch4. Fixing it to initial guess\n2025-04-15 15:23:45.251 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting n2o. Fixing it to initial guess\n2025-04-15 15:23:45.252 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:create_telluric_template:313 - Starting creation of Telluric template from ESPRESSO19\n2025-04-15 15:23:45.256 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:_search_reference_frame:271 - Using Relative humidity as the selection criterion for reference observation\n2025-04-15 15:23:45.264 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:_search_reference_frame:300 - Telluric Template from ESPRESSO19 using Frame of ESPRESSO : ESPRESSO19 data (2019-07-03T01:43:39.634; ID = 9211860738973677165) as the reference\n2025-04-15 15:23:45.265 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:create_telluric_template:336 - Starting telluric template creation, with reference ID = 9211860738973677165\n2025-04-15 15:23:45.266 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: temperature\n2025-04-15 15:23:45.267 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: co2\n2025-04-15 15:23:45.268 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: ch4\n2025-04-15 15:23:45.269 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: n2o\n2025-04-15 15:23:45.275 | DEBUG    | ASTRA.template_creation.telluric_templates.telluric_from_telfit:create_telluric_template:602 - Parameters in use: ['temperature', 'pressure', 'humidity', 'co2', 'ch4', 'n2o']\n2025-04-15 15:23:45.277 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:create_telluric_template:603 - Using params: [280.64, 750, 20.0, 385.34, 1819.0, 325.1]\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:47: UserWarning: PYSYN_CDBS is undefined; functionality will be SEVERELY crippled.\n  warnings.warn(\"PYSYN_CDBS is undefined; functionality will be SEVERELY \"\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:346: UserWarning: Extinction files not found in extinction\n  warnings.warn('Extinction files not found in %s' % (extdir, ))\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:117: UserWarning: No graph or component tables found; functionality will be SEVERELY crippled. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmg.fits\n  warnings.warn('No graph or component tables found; '\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:124: UserWarning: No thermal tables found, no thermal calculations can be performed. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmt.fits\n  warnings.warn('No thermal tables found, '\n2025-04-15 15:23:47.296 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:configure_modeler:367 - Configuring the Telfit modeler for Frame of ESPRESSO : ESPRESSO19 data (2019-07-03T01:43:39.634; ID = 9211860738973677165)\n2025-04-15 15:23:47.297 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:280 - Preparing GDAS data load!\n2025-04-15 15:23:47.298 | DEBUG    | ASTRA.internals.cache:__init__:26 - Launching new DB connection\n2025-04-15 15:23:47.304 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:287 - Launching GDAS profile downloader\n2025-04-15 15:23:47.306 | WARNING  | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:293 - Iterating over other possible frames to search for a working reference\n2025-04-15 15:23:47.308 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:317 - Starting loop to retrive GDAS profile\n2025-04-15 15:23:47.319 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:328 - Using cached version of the GDAS profile\n2025-04-15 15:23:47.321 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:361 - Finished setup of GDAS profile\n2025-04-15 15:23:47.326 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:configure_modeler:422 - Finished configurating the modeler\n2025-04-15 15:24:32.996 | INFO     | ASTRA.utils.telluric_utilities.binary_mask_from_template:create_binary_template:16 - Converting from transmittance spectra to binary mask!\n2025-04-15 15:24:33.232 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:_compute_wave_blocks:385 - Creating list of blocked features due to tellurics\n2025-04-15 15:24:33.233 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:_compute_wave_blocks:387 - Extending telluric features with the mode: &lt;TELLURIC_EXTENSION.LINES&gt;\n2025-04-15 15:24:37.078 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:277 - Storing templates from &lt;Telluric&gt; under the directory\n2025-04-15 15:24:37.079 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:281 - \t../../tmp/templates/Telluric\n2025-04-15 15:24:37.080 | INFO     | ASTRA.base_models.Template_Model:trigger_data_storage:95 - The template from ESPRESSO18 was not created. Storing nothing to disk\n2025-04-15 15:24:37.081 | INFO     | ASTRA.base_models.Template_Model:store_template:119 - Storing telfit-Telluric from ESPRESSO19 to disk\n2025-04-15 15:24:37.082 | WARNING  | ASTRA.base_models.Template_Model:store_template:135 - Disabled removal of old disk files!\n2025-04-15 15:25:10.822 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:store_template:597 - Storing template to ../../tmp/templates/Telluric/telfit_Telluric_ESPRESSO19.fits\n</pre> <p>After the model is constructed, we can remove the tellurics from all observations at once through</p> In\u00a0[2]: Copied! <pre>data.remove_telluric_features(ModelTell)\n</pre> data.remove_telluric_features(ModelTell)  <pre>/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:47: UserWarning: PYSYN_CDBS is undefined; functionality will be SEVERELY crippled.\n  warnings.warn(\"PYSYN_CDBS is undefined; functionality will be SEVERELY \"\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:346: UserWarning: Extinction files not found in extinction\n  warnings.warn('Extinction files not found in %s' % (extdir, ))\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:117: UserWarning: No graph or component tables found; functionality will be SEVERELY crippled. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmg.fits\n  warnings.warn('No graph or component tables found; '\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:124: UserWarning: No thermal tables found, no thermal calculations can be performed. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmt.fits\n  warnings.warn('No thermal tables found, '\n</pre>"},{"location":"template_creation/telluric/#telluric-models","title":"Telluric Models\u00b6","text":"<p>Similarly to stellar templates, the telluric model is constructed through a manager that will handle the construction and data storage.</p> <p>The construction of the telluric model follows a recipe:</p> <ol> <li>Construct a transmittance model from a given source (by default, Telfit)</li> <li>Find the wavelength regions in which the transmittance model is smaller than a given percentage of the continuum</li> <li>Account for the BERV by either using the +- Maximum yearly variation or by shifting the mask to all BERVS in our dataset.</li> </ol> <p>The following workflow summarizes the main steps in this process:</p> <p></p>"},{"location":"user_guide/basic_example/","title":"Basic example","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nfrom ASTRA.data_objects import DataClassManager\nfrom ASTRA.data_objects.DataClass import DataClass\nfrom ASTRA.Instruments import ESPRESSO\nfrom ASTRA.Quality_Control.activity_indicators import Indicators\nfrom ASTRA.template_creation.StellarModel import StellarModel\nfrom ASTRA.template_creation.TelluricModel import TelluricModel\nfrom ASTRA.utils.choices import TELLURIC_CREATION_MODE\n\nstorage_path = Path(\"tmp\")\nmanager = DataClassManager()\nmanager.start()\n\nd: DataClass = manager.DataClass(\n    list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")),\n    storage_path=storage_path,\n    instrument=ESPRESSO,\n)\n\n\n\ninds = Indicators()\nd.remove_activity_lines(inds)\n\n\nModelTell = TelluricModel(\n    usage_mode=\"individual\",\n    user_configs={\"CREATION_MODE\": TELLURIC_CREATION_MODE.telfit},\n    root_folder_path=storage_path,\n)\n\nModelTell.Generate_Model(\n    dataClass=d,\n    telluric_configs={},\n    force_computation=False,\n    store_templates=True,\n)\nd.remove_telluric_features(ModelTell)\n\nstell = StellarModel(\n    storage_path,\n    user_configs={},\n)\nstell.Generate_Model(\n    dataClass=d,\n    template_configs={},\n)\n</pre> from pathlib import Path  from ASTRA.data_objects import DataClassManager from ASTRA.data_objects.DataClass import DataClass from ASTRA.Instruments import ESPRESSO from ASTRA.Quality_Control.activity_indicators import Indicators from ASTRA.template_creation.StellarModel import StellarModel from ASTRA.template_creation.TelluricModel import TelluricModel from ASTRA.utils.choices import TELLURIC_CREATION_MODE  storage_path = Path(\"tmp\") manager = DataClassManager() manager.start()  d: DataClass = manager.DataClass(     list(Path(\"/home/amiguel/spectra_collection/ESPRESSO/proxima\").glob(\"*.fits\")),     storage_path=storage_path,     instrument=ESPRESSO, )    inds = Indicators() d.remove_activity_lines(inds)   ModelTell = TelluricModel(     usage_mode=\"individual\",     user_configs={\"CREATION_MODE\": TELLURIC_CREATION_MODE.telfit},     root_folder_path=storage_path, )  ModelTell.Generate_Model(     dataClass=d,     telluric_configs={},     force_computation=False,     store_templates=True, ) d.remove_telluric_features(ModelTell)  stell = StellarModel(     storage_path,     user_configs={}, ) stell.Generate_Model(     dataClass=d,     template_configs={}, )   <pre>2025-04-14 21:27:00.552 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of  - \n2025-04-14 21:27:00.558 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:27:00.560 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:27:00.562 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:27:00.568 | INFO     | ASTRA.data_objects.DataClass:__init__:126 - DataClass opening 3 files from a list/tuple\n2025-04-14 21:27:00.571 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-14 21:27:00.573 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:27:00.594 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:27:00.598 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -6292580960432662955 rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-14 21:27:00.715 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-14T02:07:49.063_S2D_A.fits\n2025-04-14 21:27:00.717 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:27:00.994 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:27:00.998 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -2977376033459950602 rejected 15 orders for having SNR smaller than 5: 0-12, 32-33\n2025-04-14 21:27:01.000 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-20T01:43:40.032_S2D_A.fits\n2025-04-14 21:27:01.003 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 21:27:01.019 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:27:01.022 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -7145805177571901523 rejected 16 orders for having SNR smaller than 5: 0-13, 32-33\n2025-04-14 21:27:01.024 | DEBUG    | ASTRA.data_objects.DataClass:__init__:154 - Selected 3 observations from disk\n2025-04-14 21:27:01.026 | INFO     | ASTRA.data_objects.DataClass:_collect_MetaData:369 - Collecting MetaData from the observations\n2025-04-14 21:27:01.028 | WARNING  | ASTRA.data_objects.Target:__init__:73 - Target dictionary not found in &lt;None&gt;\n2025-04-14 21:27:01.029 | DEBUG    | ASTRA.data_objects.Target:clean_targ_list:98 - Parsing through loaded OBJECTs\n2025-04-14 21:27:01.031 | INFO     | ASTRA.data_objects.Target:__init__:92 - Validated target to be V V645 Cen\n2025-04-14 21:27:01.033 | INFO     | ASTRA.data_objects.DataClass:show_loadedData_table:885 - --------------------------------------------------------------------\n--------------------------------------------------------------------\n  subInstrument    Total OBS    Valid OBS [warnings]   INVALID OBS   \n--------------------------------------------------------------------\n    ESPRESSO18         0               0 [0]                0        \n    ESPRESSO19         3               3 [0]                0        \n      Total            3               3 [0]                0        \n--------------------------------------------------------------------\n2025-04-14 21:27:01.034 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:894 - Checking if the instrument has extra data to load\n2025-04-14 21:27:01.036 | INFO     | ASTRA.data_objects.DataClass:load_instrument_extra_information:901 - Current instrument does not need to load anything from the outside\n2025-04-14 21:27:01.046 | INFO     | ASTRA.data_objects.DataClass:remove_activity_lines:216 - Computing activity windows for each RV measurements\n2025-04-14 21:27:01.051 | INFO     | ASTRA.base_models.TemplateFramework:__init__:72 - Starting Telluric Model\n2025-04-14 21:27:01.052 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of BASE - TemplateFramework\n2025-04-14 21:27:01.054 | DEBUG    | ASTRA.utils.UserConfigs:update_configs_with_values:198 - Configuration &lt;CREATION_MODE&gt; taking the value: TELLURIC_CREATION_MODE.telfit\n2025-04-14 21:27:01.054 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:27:01.055 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:27:01.056 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:27:01.057 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;APPLICATION_MODE&gt; using the default value: TELLURIC_APPLICATION_MODE.removal\n2025-04-14 21:27:01.058 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;EXTENSION_MODE&gt; using the default value: TELLURIC_EXTENSION.LINES\n2025-04-14 21:27:01.060 | INFO     | ASTRA.template_creation.TelluricModel:__init__:91 - Starting Telluric Model\n2025-04-14 21:27:01.061 | DEBUG    | ASTRA.base_models.TemplateFramework:Generate_Model:138 - Starting the creation of Telluric models!\n2025-04-14 21:27:01.061 | INFO     | ASTRA.base_models.TemplateFramework:Generate_Model:141 - Attempting to load previous Templates from disk before creating them\n2025-04-14 21:27:01.063 | DEBUG    | ASTRA.base_models.TemplateFramework:load_templates_from_disk:178 - Searching in : tmp/templates/Telluric for TELLURIC_CREATION_MODE.telfit\n2025-04-14 21:27:01.063 | INFO     | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:180 - Loading Telluric template from disk inside directory\n2025-04-14 21:27:01.063 | INFO     | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:181 - \ttmp/templates/Telluric\n2025-04-14 21:27:01.064 | INFO     | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:192 - Found 0 available templates: [] of type TELLURIC_CREATION_MODE.telfit\n2025-04-14 21:27:01.065 | CRITICAL | ASTRA.template_creation.TelluricModel:_find_templates_from_disk:199 - Could not find templates to load!\n2025-04-14 21:27:01.065 | INFO     | ASTRA.base_models.TemplateFramework:Generate_Model:145 - No templates to load from disk. Creating all from scratch\n2025-04-14 21:27:01.066 | INFO     | ASTRA.template_creation.TelluricModel:_compute_template:205 - Using template of type: TELLURIC_CREATION_MODE.telfit\n2025-04-14 21:27:01.067 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of telfit-Telluric from ESPRESSO18\n2025-04-14 21:27:01.068 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:27:01.069 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:27:01.070 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:27:01.072 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;continuum_percentage_drop&gt; using the default value: 1\n2025-04-14 21:27:01.074 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;force_download&gt; using the default value: False\n2025-04-14 21:27:01.075 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;inverse_mask&gt; using the default value: False\n2025-04-14 21:27:01.077 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;atmosphere_profile&gt; using the default value: GDAS\n2025-04-14 21:27:01.078 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_MODEL&gt; using the default value: False\n2025-04-14 21:27:01.079 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;TELFIT_HUMIDITY_THRESHOLD&gt; using the default value: -1\n2025-04-14 21:27:01.080 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_WAVELENGTH_STEP_SIZE&gt; using the default value: 0.001\n2025-04-14 21:27:01.080 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;PARAMS_TO_FIT&gt; using the default value: ['pressure', 'humidity']\n2025-04-14 21:27:01.081 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;USE_GRID_OF_TRANSMITTANCE&gt; using the default value: False\n2025-04-14 21:27:01.081 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;GRID_MAIN_PATH&gt; using the default value: None\n2025-04-14 21:27:01.082 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;IND_WATER_MASK_THRESHOLD&gt; using the default value: 100000000.0\n2025-04-14 21:27:01.084 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of telfit-Telluric from ESPRESSO18\n2025-04-14 21:27:01.085 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:load_information_from_DataClass:166 - Template telfit-Telluric from ESPRESSO18 loading data from the dataClass\n2025-04-14 21:27:01.086 | WARNING  | ASTRA.template_creation.telluric_templates.Telluric_Template:_load_BERV_info:200 - ESPRESSO18 has no valid observations. Not computing telluric template\n2025-04-14 21:27:01.091 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:create_telluric_template:313 - Starting creation of Telluric template from ESPRESSO18\n2025-04-14 21:27:01.092 | WARNING  | ASTRA.template_creation.telluric_templates.Telluric_Template:_search_reference_frame:256 - ESPRESSO18 has no valid observations. Not computing telluric template\n2025-04-14 21:27:01.093 | WARNING  | ASTRA.base_models.Template_Model:_base_checks_for_template_creation:102 - Template will not be created. Check previous error messages\n2025-04-14 21:27:01.094 | INFO     | ASTRA.template_creation.TelluricModel:_compute_template:205 - Using template of type: TELLURIC_CREATION_MODE.telfit\n2025-04-14 21:27:01.094 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of telfit-Telluric from ESPRESSO19\n2025-04-14 21:27:01.095 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:27:01.096 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:27:01.096 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:27:01.097 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;continuum_percentage_drop&gt; using the default value: 1\n2025-04-14 21:27:01.097 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;force_download&gt; using the default value: False\n2025-04-14 21:27:01.098 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;inverse_mask&gt; using the default value: False\n2025-04-14 21:27:01.098 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;atmosphere_profile&gt; using the default value: GDAS\n2025-04-14 21:27:01.099 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_MODEL&gt; using the default value: False\n2025-04-14 21:27:01.099 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;TELFIT_HUMIDITY_THRESHOLD&gt; using the default value: -1\n2025-04-14 21:27:01.100 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FIT_WAVELENGTH_STEP_SIZE&gt; using the default value: 0.001\n2025-04-14 21:27:01.102 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;PARAMS_TO_FIT&gt; using the default value: ['pressure', 'humidity']\n2025-04-14 21:27:01.103 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;USE_GRID_OF_TRANSMITTANCE&gt; using the default value: False\n2025-04-14 21:27:01.104 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;GRID_MAIN_PATH&gt; using the default value: None\n2025-04-14 21:27:01.105 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;IND_WATER_MASK_THRESHOLD&gt; using the default value: 100000000.0\n2025-04-14 21:27:01.106 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of telfit-Telluric from ESPRESSO19\n2025-04-14 21:27:01.107 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:load_information_from_DataClass:166 - Template telfit-Telluric from ESPRESSO19 loading data from the dataClass\n2025-04-14 21:27:01.118 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:_generate_model_parameters:150 - Generating the parameters of the model applied in telfit-Telluric from ESPRESSO19\n2025-04-14 21:27:01.119 | INFO     | ASTRA.ModelParameters.Model:generate_priors:20 - Generating priors of the model' parameters\n2025-04-14 21:27:01.134 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting temperature. Fixing it to initial guess\n2025-04-14 21:27:01.136 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting co2. Fixing it to initial guess\n2025-04-14 21:27:01.137 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting ch4. Fixing it to initial guess\n2025-04-14 21:27:01.139 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_generate_model_parameters:723 - telfit-Telluric from ESPRESSO19 not fitting n2o. Fixing it to initial guess\n2025-04-14 21:27:01.141 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:create_telluric_template:313 - Starting creation of Telluric template from ESPRESSO19\n2025-04-14 21:27:01.144 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:_search_reference_frame:271 - Using Relative humidity as the selection criterion for reference observation\n2025-04-14 21:27:01.154 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:_search_reference_frame:300 - Telluric Template from ESPRESSO19 using Frame of ESPRESSO : ESPRESSO19 data (2019-07-03T01:43:39.634; ID = -6292580960432662955) as the reference\n2025-04-14 21:27:01.155 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:create_telluric_template:336 - Starting telluric template creation, with reference ID = -6292580960432662955\n2025-04-14 21:27:01.156 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: temperature\n2025-04-14 21:27:01.157 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: co2\n2025-04-14 21:27:01.159 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: ch4\n2025-04-14 21:27:01.160 | WARNING  | ASTRA.ModelParameters.Parameter:disable_param:263 - Attempting to disable param that is already disabled: n2o\n2025-04-14 21:27:01.164 | DEBUG    | ASTRA.template_creation.telluric_templates.telluric_from_telfit:create_telluric_template:602 - Parameters in use: ['temperature', 'pressure', 'humidity', 'co2', 'ch4', 'n2o']\n2025-04-14 21:27:01.165 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:create_telluric_template:603 - Using params: [280.64, 750, 20.0, 385.34, 1819.0, 325.1]\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:47: UserWarning: PYSYN_CDBS is undefined; functionality will be SEVERELY crippled.\n  warnings.warn(\"PYSYN_CDBS is undefined; functionality will be SEVERELY \"\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:346: UserWarning: Extinction files not found in extinction\n  warnings.warn('Extinction files not found in %s' % (extdir, ))\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:117: UserWarning: No graph or component tables found; functionality will be SEVERELY crippled. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmg.fits\n  warnings.warn('No graph or component tables found; '\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:124: UserWarning: No thermal tables found, no thermal calculations can be performed. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmt.fits\n  warnings.warn('No thermal tables found, '\n2025-04-14 21:27:03.614 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:configure_modeler:367 - Configuring the Telfit modeler for Frame of ESPRESSO : ESPRESSO19 data (2019-07-03T01:43:39.634; ID = -6292580960432662955)\n2025-04-14 21:27:03.615 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:280 - Preparing GDAS data load!\n2025-04-14 21:27:03.616 | DEBUG    | ASTRA.internals.cache:__init__:26 - Launching new DB connection\n2025-04-14 21:27:03.622 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:287 - Launching GDAS profile downloader\n2025-04-14 21:27:03.623 | WARNING  | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:293 - Iterating over other possible frames to search for a working reference\n2025-04-14 21:27:03.624 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:317 - Starting loop to retrive GDAS profile\n2025-04-14 21:27:03.634 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:328 - Using cached version of the GDAS profile\n2025-04-14 21:27:03.635 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:_prepare_GDAS_data:361 - Finished setup of GDAS profile\n2025-04-14 21:27:03.638 | INFO     | ASTRA.template_creation.telluric_templates.telluric_from_telfit:configure_modeler:422 - Finished configurating the modeler\n2025-04-14 21:27:48.705 | INFO     | ASTRA.utils.telluric_utilities.binary_mask_from_template:create_binary_template:16 - Converting from transmittance spectra to binary mask!\n2025-04-14 21:27:48.965 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:_compute_wave_blocks:385 - Creating list of blocked features due to tellurics\n2025-04-14 21:27:48.967 | INFO     | ASTRA.template_creation.telluric_templates.Telluric_Template:_compute_wave_blocks:387 - Extending telluric features with the mode: &lt;TELLURIC_EXTENSION.LINES&gt;\n2025-04-14 21:27:52.759 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:277 - Storing templates from &lt;Telluric&gt; under the directory\n2025-04-14 21:27:52.760 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:281 - \ttmp/templates/Telluric\n2025-04-14 21:27:52.761 | INFO     | ASTRA.base_models.Template_Model:trigger_data_storage:95 - The template was not created. Storing nothing to disk\n2025-04-14 21:27:52.762 | INFO     | ASTRA.base_models.Template_Model:store_template:119 - Storing telfit-Telluric from ESPRESSO19 to disk\n2025-04-14 21:27:52.763 | WARNING  | ASTRA.base_models.Template_Model:store_template:135 - Disabled removal of old disk files!\n2025-04-14 21:28:26.200 | DEBUG    | ASTRA.template_creation.telluric_templates.Telluric_Template:store_template:597 - Storing template to tmp/templates/Telluric/telfit_Telluric_ESPRESSO19.fits\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:47: UserWarning: PYSYN_CDBS is undefined; functionality will be SEVERELY crippled.\n  warnings.warn(\"PYSYN_CDBS is undefined; functionality will be SEVERELY \"\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/locations.py:346: UserWarning: Extinction files not found in extinction\n  warnings.warn('Extinction files not found in %s' % (extdir, ))\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:117: UserWarning: No graph or component tables found; functionality will be SEVERELY crippled. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmg.fits\n  warnings.warn('No graph or component tables found; '\n/home/amiguel/development/ASTRA/.venv/lib/python3.12/site-packages/pysynphot/refs.py:124: UserWarning: No thermal tables found, no thermal calculations can be performed. No files found for http://ssb.stsci.edu/cdbs_open/cdbs/mtab/*_tmt.fits\n  warnings.warn('No thermal tables found, '\n2025-04-14 21:28:30.783 | INFO     | ASTRA.base_models.TemplateFramework:__init__:72 - Starting Stellar Model\n2025-04-14 21:28:30.784 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of SpectralModel - Stellar\n2025-04-14 21:28:30.785 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:28:30.786 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:28:30.786 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:28:30.787 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;CREATION_MODE&gt; using the default value: STELLAR_CREATION_MODE.Sum\n2025-04-14 21:28:30.788 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;ALIGNEMENT_RV_SOURCE&gt; using the default value: DRS\n2025-04-14 21:28:30.789 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;PREVIOUS_SBART_PATH&gt; using the default value: \n2025-04-14 21:28:30.790 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;USE_MERGED_RVS&gt; using the default value: False\n2025-04-14 21:28:30.791 | INFO     | ASTRA.template_creation.StellarModel:Generate_Model:165 - Using CCF RVs as the basis for the creation of the stellar models\n2025-04-14 21:28:30.793 | DEBUG    | ASTRA.base_models.TemplateFramework:Generate_Model:138 - Starting the creation of Stellar models!\n2025-04-14 21:28:30.793 | INFO     | ASTRA.base_models.TemplateFramework:Generate_Model:141 - Attempting to load previous Templates from disk before creating them\n2025-04-14 21:28:30.794 | DEBUG    | ASTRA.base_models.TemplateFramework:load_templates_from_disk:178 - Searching in : tmp/templates/Stellar/Iteration_0 for STELLAR_CREATION_MODE.Sum\n2025-04-14 21:28:30.795 | INFO     | ASTRA.base_models.TemplateFramework:_find_templates_from_disk:248 - Loading Stellar template of type Sum from disk inside directory\n2025-04-14 21:28:30.796 | INFO     | ASTRA.base_models.TemplateFramework:_find_templates_from_disk:253 - \ttmp/templates/Stellar/Iteration_0\n2025-04-14 21:28:30.797 | INFO     | ASTRA.base_models.TemplateFramework:_find_templates_from_disk:255 - Found 0 available templates: [] of type Sum\n2025-04-14 21:28:30.798 | WARNING  | ASTRA.base_models.TemplateFramework:_find_templates_from_disk:263 - Could not find template to load in tmp/templates/Stellar/Iteration_0\n2025-04-14 21:28:30.799 | INFO     | ASTRA.base_models.TemplateFramework:Generate_Model:145 - No templates to load from disk. Creating all from scratch\n2025-04-14 21:28:30.824 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of Sum-Stellar from ESPRESSO18\n2025-04-14 21:28:30.825 | DEBUG    | ASTRA.utils.UserConfigs:update_configs_with_values:198 - Configuration &lt;ALIGNEMENT_RV_SOURCE&gt; taking the value: DRS\n2025-04-14 21:28:30.826 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:28:30.827 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:28:30.828 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:28:30.828 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;CONSTANT_RV_GUESS&gt; using the default value: False\n2025-04-14 21:28:30.830 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;NUMBER_WORKERS&gt; using the default value: 1\n2025-04-14 21:28:30.831 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MEMORY_SAVE_MODE&gt; using the default value: False\n2025-04-14 21:28:30.831 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MINIMUM_NUMBER_OBS&gt; using the default value: 3\n2025-04-14 21:28:30.832 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_threshold_for_template&gt; using the default value: 1\n2025-04-14 21:28:30.833 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOL_MODE&gt; using the default value: SPECTRA_INTERPOL_MODE.SPLINES\n2025-04-14 21:28:30.833 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SPLINE_TYPE&gt; using the default value: SPLINE_INTERPOL_MODE.CUBIC_SPLINE\n2025-04-14 21:28:30.833 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOLATION_ERR_PROP&gt; using the default value: INTERPOLATION_ERR_PROP.interpolation\n2025-04-14 21:28:30.834 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_CONFIGS&gt; using the default value: FLUX_SMOOTH_CONFIGS.NONE\n2025-04-14 21:28:30.835 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_WINDOW_SIZE&gt; using the default value: 15\n2025-04-14 21:28:30.835 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_DEG&gt; using the default value: 2\n2025-04-14 21:28:30.835 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_ORDER&gt; using the default value: FLUX_SMOOTH_ORDER.AFTER\n2025-04-14 21:28:30.836 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Sum-Stellar from ESPRESSO18\n2025-04-14 21:28:30.838 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:132 - Starting creation of Stellar template from ESPRESSO18\n2025-04-14 21:28:30.852 | CRITICAL | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:144 - ESPRESSO18 has no valid observations. Not computing Stellar template\n2025-04-14 21:28:30.854 | WARNING  | ASTRA.base_models.Template_Model:_base_checks_for_template_creation:102 - Template will not be created. Check previous error messages\n2025-04-14 21:28:30.856 | WARNING  | ASTRA.template_creation.StellarModel:_compute_template:197 - Key &lt;ALIGNEMENT_RV_SOURCE&gt; from Stellar Model over-riding the one from the template configs\n2025-04-14 21:28:30.858 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:216 - Generating internal configs of Sum-Stellar from ESPRESSO19\n2025-04-14 21:28:30.859 | DEBUG    | ASTRA.utils.UserConfigs:update_configs_with_values:198 - Configuration &lt;ALIGNEMENT_RV_SOURCE&gt; taking the value: DRS\n2025-04-14 21:28:30.860 | INFO     | ASTRA.utils.UserConfigs:receive_user_inputs:221 - Checking for any parameter that will take default value\n2025-04-14 21:28:30.862 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SAVE_DISK_SPACE&gt; using the default value: DISK_SAVE_MODE.DISABLED\n2025-04-14 21:28:30.863 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;WORKING_MODE&gt; using the default value: WORKING_MODE.ONE_SHOT\n2025-04-14 21:28:30.864 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;CONSTANT_RV_GUESS&gt; using the default value: False\n2025-04-14 21:28:30.865 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;NUMBER_WORKERS&gt; using the default value: 1\n2025-04-14 21:28:30.866 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MEMORY_SAVE_MODE&gt; using the default value: False\n2025-04-14 21:28:30.870 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;MINIMUM_NUMBER_OBS&gt; using the default value: 3\n2025-04-14 21:28:30.871 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_threshold_for_template&gt; using the default value: 1\n2025-04-14 21:28:30.873 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOL_MODE&gt; using the default value: SPECTRA_INTERPOL_MODE.SPLINES\n2025-04-14 21:28:30.875 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;SPLINE_TYPE&gt; using the default value: SPLINE_INTERPOL_MODE.CUBIC_SPLINE\n2025-04-14 21:28:30.877 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;INTERPOLATION_ERR_PROP&gt; using the default value: INTERPOLATION_ERR_PROP.interpolation\n2025-04-14 21:28:30.878 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_CONFIGS&gt; using the default value: FLUX_SMOOTH_CONFIGS.NONE\n2025-04-14 21:28:30.879 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_WINDOW_SIZE&gt; using the default value: 15\n2025-04-14 21:28:30.880 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_DEG&gt; using the default value: 2\n2025-04-14 21:28:30.881 | DEBUG    | ASTRA.utils.UserConfigs:receive_user_inputs:228 - Configuration &lt;FLUX_SMOOTH_ORDER&gt; using the default value: FLUX_SMOOTH_ORDER.AFTER\n2025-04-14 21:28:30.882 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Sum-Stellar from ESPRESSO19\n2025-04-14 21:28:30.882 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:132 - Starting creation of Stellar template from ESPRESSO19\n2025-04-14 21:28:30.884 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:create_stellar_template:162 - Evaluating spectral conditions to select the valid observations from ESPRESSO19\n2025-04-14 21:28:31.022 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:862 - Opening the S2D arrays from r.ESPRE.2019-07-20T01:43:40.032_S2D_A.fits\n2025-04-14 21:28:31.059 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-14 21:28:31.143 | DEBUG    | ASTRA.base_models.Frame:build_mask:628 - Cleaning wavelength regions from ['ACTIVITY_INDICATOR', 'TELLURIC']\n2025-04-14 21:28:31.606 | DEBUG    | ASTRA.base_models.Frame:build_mask:646 - Removed 2933 regions (11 + 2922)\n2025-04-14 21:28:31.609 | DEBUG    | ASTRA.base_models.Frame:build_mask:672 - Ensuring that we have increasing wavelengths\n2025-04-14 21:28:31.636 | DEBUG    | ASTRA.base_models.Frame:build_mask:678 - Took 0.4599037170410156 seconds (0.004516124725341797 + 0.45538759231567383)\n2025-04-14 21:28:31.639 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:28:31.664 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:724 - Frame -7145805177571901523 rejected 16 orders due for having less than 0.25 valid pixels: 0-13, 32-33\n2025-04-14 21:28:31.668 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -7145805177571901523 rejected 16 orders for having SNR smaller than 5: 0-13, 32-33\n2025-04-14 21:28:32.061 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:140 - Using observation from Frame of ESPRESSO : ESPRESSO19 data (2019-07-20T01:43:40.031; ID = -7145805177571901523) as a basis for stellar template construction\n2025-04-14 21:28:32.063 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:145 - Using frameIDs: [-6292580960432662955, -2977376033459950602, -7145805177571901523]\n2025-04-14 21:28:32.064 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:157 - Launching 1 workers!\n2025-04-14 21:28:32.064 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:convert_to_shared_mem:553 - Putting the stellar template in shared memory\n2025-04-14 21:28:32.155 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:862 - Opening the S2D arrays from r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-14 21:28:32.192 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-14 21:28:32.268 | DEBUG    | ASTRA.base_models.Frame:build_mask:628 - Cleaning wavelength regions from ['ACTIVITY_INDICATOR', 'TELLURIC']\n2025-04-14 21:28:32.543 | DEBUG    | ASTRA.base_models.Frame:build_mask:646 - Removed 2933 regions (11 + 2922)\n2025-04-14 21:28:32.545 | DEBUG    | ASTRA.base_models.Frame:build_mask:672 - Ensuring that we have increasing wavelengths\n2025-04-14 21:28:32.562 | DEBUG    | ASTRA.base_models.Frame:build_mask:678 - Took 0.2728245258331299 seconds (0.002228975296020508 + 0.2705955505371094)\n2025-04-14 21:28:32.565 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:28:32.593 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:724 - Frame -6292580960432662955 rejected 37 orders due for having less than 0.25 valid pixels: 0-36\n2025-04-14 21:28:32.597 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -6292580960432662955 rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-14 21:28:33.717 | DEBUG    | ASTRA.base_models.Frame:load_S2D_data:862 - Opening the S2D arrays from r.ESPRE.2019-07-14T02:07:49.063_S2D_A.fits\n2025-04-14 21:28:33.756 | WARNING  | ASTRA.Instruments.ESO_PIPELINE:load_ESO_DRS_S2D_data:327 - Not applying correction to blue-red flux balance!\n2025-04-14 21:28:33.841 | DEBUG    | ASTRA.base_models.Frame:build_mask:628 - Cleaning wavelength regions from ['ACTIVITY_INDICATOR', 'TELLURIC']\n2025-04-14 21:28:34.148 | DEBUG    | ASTRA.base_models.Frame:build_mask:646 - Removed 2933 regions (11 + 2922)\n2025-04-14 21:28:34.150 | DEBUG    | ASTRA.base_models.Frame:build_mask:672 - Ensuring that we have increasing wavelengths\n2025-04-14 21:28:34.182 | DEBUG    | ASTRA.base_models.Frame:build_mask:678 - Took 0.3039066791534424 seconds (0.0019614696502685547 + 0.30194520950317383)\n2025-04-14 21:28:34.187 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 21:28:34.248 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:724 - Frame -2977376033459950602 rejected 15 orders due for having less than 0.25 valid pixels: 0-12, 32-33\n2025-04-14 21:28:34.252 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame -2977376033459950602 rejected 15 orders for having SNR smaller than 5: 0-12, 32-33\n2025-04-14 21:28:36.764 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:217 - Updating template mask\n2025-04-14 21:28:36.830 | DEBUG    | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:226 - Ensuring increasing wavelenghs in the stellar template\n2025-04-14 21:28:36.853 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:launch_parallel:239 - Construction of stellar template took 4.698757886886597\n2025-04-14 21:28:36.858 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 0 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.859 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 1 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.860 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 2 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.861 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 3 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.862 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 4 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.864 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 5 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.866 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 6 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.867 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 7 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.869 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 8 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.869 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 9 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.870 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 10 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.871 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 11 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.872 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 12 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.872 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 13 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.873 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 14 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.874 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 15 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.874 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 16 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.874 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 17 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.875 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 18 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.875 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 19 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.876 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 20 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.877 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 21 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.878 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 22 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.878 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 23 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.879 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 24 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.880 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 25 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.881 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 26 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.882 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 27 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.884 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 28 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.885 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 29 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.886 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 30 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.888 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 31 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.890 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 32 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.892 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 33 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.893 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 34 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.895 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 35 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.897 | WARNING  | ASTRA.template_creation.stellar_templates.Stellar_Template:evaluate_bad_orders:306 - Stellar template rejecting order 36 due to having more than 9011/9111 pixels masked\n2025-04-14 21:28:36.901 | INFO     | ASTRA.template_creation.stellar_templates.sum_stellar:create_stellar_template:103 - Closing shared memory interfaces of the Stellar template\n2025-04-14 21:28:36.904 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:cleanup_shared_memory:578 - Cleaning the shared memory interfaces from the Stellar template creation\n2025-04-14 21:28:36.905 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:_close_workers:584 - Sum-Stellar from ESPRESSO19 closing the workers\n2025-04-14 21:28:36.907 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:_close_queues:601 - Sum-Stellar from ESPRESSO19 closing the communication queues\n2025-04-14 21:28:36.909 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:_close_shared_memory_arrays:590 - Sum-Stellar from ESPRESSO19 closing the shared memory array\n2025-04-14 21:28:36.913 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:277 - Storing templates from &lt;Stellar&gt; under the directory\n2025-04-14 21:28:36.914 | INFO     | ASTRA.base_models.TemplateFramework:store_templates_to_disk:281 - \ttmp/templates/Stellar/Iteration_0\n2025-04-14 21:28:36.917 | INFO     | ASTRA.base_models.Template_Model:trigger_data_storage:95 - The template was not created. Storing nothing to disk\n2025-04-14 21:28:36.921 | INFO     | ASTRA.base_models.Template_Model:store_template:119 - Storing Sum-Stellar from ESPRESSO19 to disk\n2025-04-14 21:28:36.922 | WARNING  | ASTRA.base_models.Template_Model:store_template:135 - Disabled removal of old disk files!\n2025-04-14 21:28:37.015 | DEBUG    | ASTRA.template_creation.stellar_templates.Stellar_Template:store_template:414 - Storing used filepaths to disk\n2025-04-14 21:28:37.017 | INFO     | ASTRA.template_creation.stellar_templates.Stellar_Template:_store_json_information:331 - Storing template flags to disk\n</pre>"},{"location":"user_guide/basic_example/#basic-example","title":"Basic example\u00b6","text":"<p>In this notebook we provide a quick run-through of the basic usage of ASTRA, that will be explored in detail in the following Sections.</p> <p>This will do the following steps:</p> <ol> <li>Load data from disk</li> <li>Remove activity-sensitive lines</li> <li>Construct a telluric model and mask the affacted wavelength regions</li> <li>Construct a stellar model using those observations</li> </ol> <p>This will store the data products under a provided directory and it will allow for an a posterior load of disk products (to avoid multiple reconstructions of the templates).</p>"},{"location":"user_guide/configuration/","title":"Configuration of ASTRA objects","text":"<p>Astra objects have a wide number of configurable parameters, with most of them being optional (with sensible values as the default ones). Furthermore, every configurable value that the user provides will pass through a validation layer, to ensure proper initialization.</p> <p>The easiest way to find all parameters, alongside their description is through a method that exist in all ASTRA objects:</p> In\u00a0[1]: Copied! <pre>from ASTRA.template_creation.StellarModel import StellarModel\n\nStellarModel.config_help()\n</pre> from ASTRA.template_creation.StellarModel import StellarModel  StellarModel.config_help() <pre>Configurations:\n\nName:: SAVE_DISK_SPACE\n\tDescription:: Save disk space in the outputs if different than None.\n\tMandatory:: False\n\tDefault value:: DISK_SAVE_MODE.DISABLED\n\tConstraints:: Value from list &lt;&lt;enum 'DISK_SAVE_MODE'&gt;&gt;\n \nName:: WORKING_MODE\n\tDescription:: How to store the output files. If one-shot, overwrites all files, otherwise updates products\n\tMandatory:: False\n\tDefault value:: WORKING_MODE.ONE_SHOT\n\tConstraints:: Value from list &lt;&lt;enum 'WORKING_MODE'&gt;&gt;\n \nName:: CREATION_MODE\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: STELLAR_CREATION_MODE.Sum\n\tConstraints:: Value from list &lt;&lt;enum 'STELLAR_CREATION_MODE'&gt;&gt;\n \nName:: ALIGNEMENT_RV_SOURCE\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: DRS\n\tConstraints:: Value from list &lt;['DRS', 'SBART']&gt;\n \nName:: PREVIOUS_SBART_PATH\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: \n\tConstraints:: Value from dtype &lt;(&lt;class 'str'&gt;, &lt;class 'pathlib.Path'&gt;)&gt;\n \nName:: USE_MERGED_RVS\n\tDescription:: None\n\tMandatory:: False\n\tDefault value:: False\n\tConstraints:: Value from dtype &lt;(&lt;class 'bool'&gt;,)&gt;\n \n\n</pre> <p>Then, the configuration of the ASTRA objects will be done through a argument called user_configs at the time of instantiation. If the keyword is either marked as Mandatory or the provided value does not meet the constraint, then an Exception will be raised.</p> <p>All enum items are stored in the following sub-package:</p> In\u00a0[4]: Copied! <pre>from ASTRA.utils import choices\n\ndir(choices)\n</pre> from ASTRA.utils import choices  dir(choices) Out[4]: <pre>['DISK_SAVE_MODE',\n 'Enum',\n 'FLUX_SMOOTH_CONFIGS',\n 'FLUX_SMOOTH_ORDER',\n 'INTERPOLATION_ERR_PROP',\n 'SPECTRA_INTERPOL_MODE',\n 'SPLINE_INTERPOL_MODE',\n 'STELLAR_CREATION_MODE',\n 'TELLURIC_APPLICATION_MODE',\n 'TELLURIC_CREATION_MODE',\n 'TELLURIC_EXTENSION',\n 'WORKING_MODE',\n '__builtins__',\n '__cached__',\n '__doc__',\n '__file__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__']</pre> <p>After instantiation, we can still update any of ASTRA configurations, through the update_user_configs method. Once again, the new config values will be parsed through the validation layer to ensure compliance with the parameter guidelines.</p> In\u00a0[10]: Copied! <pre>from ASTRA.Instruments import ESPRESSO\n\nframe = ESPRESSO(file_path=\"/home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\",\n                 user_configs={}\n                 )\nframe.generate_root_path(\"tmp\")\n\nfor fluxcorr in [True, \n                 False,\n                 None # It will fail, as the apply_FluxCorr configuration only accepts boolean values\n                 ]:\n    print(\"Update ASTRA config value to\", fluxcorr)\n    frame.update_user_configs({\"apply_FluxCorr\": fluxcorr})\n</pre> from ASTRA.Instruments import ESPRESSO  frame = ESPRESSO(file_path=\"/home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\",                  user_configs={}                  ) frame.generate_root_path(\"tmp\")  for fluxcorr in [True,                   False,                  None # It will fail, as the apply_FluxCorr configuration only accepts boolean values                  ]:     print(\"Update ASTRA config value to\", fluxcorr)     frame.update_user_configs({\"apply_FluxCorr\": fluxcorr}) <pre>2025-04-14 22:35:09.082 | INFO     | ASTRA.base_models.Frame:__init__:253 - Creating frame from: /home/amiguel/spectra_collection/ESPRESSO/proxima/r.ESPRE.2019-07-03T01:43:39.634_S2D_A.fits\n2025-04-14 22:35:09.084 | WARNING  | ASTRA.Components.SpectrumComponent:regenerate_order_status:96 - Resetting order status of Frame - ESPRESSO\n2025-04-14 22:35:09.103 | DEBUG    | ASTRA.base_models.Frame:assess_bad_orders:711 - Rejecting spectral orders\n2025-04-14 22:35:09.106 | INFO     | ASTRA.base_models.Frame:assess_bad_orders:741 - Frame None rejected 37 orders for having SNR smaller than 5: 0-36\n2025-04-14 22:35:09.108 | CRITICAL | ASTRA.utils.UserConfigs:update_configs_with_values:191 - User-given parameter apply_FluxCorr does not meet the constraints\n</pre> <pre>Update ASTRA config value to True\nUpdate ASTRA config value to False\nUpdate ASTRA config value to None\n</pre> <pre>\n---------------------------------------------------------------------------\nInvalidConfiguration                      Traceback (most recent call last)\nFile ~/development/ASTRA/src/ASTRA/utils/UserConfigs.py:189, in InternalParameters.update_configs_with_values(self, user_configs)\n    188 try:\n--&gt; 189     parameter_def_information.apply_constraints_to_value(key, value)\n    190 except InvalidConfiguration as exc:\n\nFile ~/development/ASTRA/src/ASTRA/utils/UserConfigs.py:68, in UserParam.apply_constraints_to_value(self, param_name, value)\n     61 \"\"\"Apply the constraints of this parameter to a given value.\n     62 \n     63 Args:\n   (...)     66 \n     67 \"\"\"\n---&gt; 68 self._valueConstraint.check_if_value_meets_constraint(value)\n\nFile ~/development/ASTRA/src/ASTRA/utils/parameter_validators.py:67, in Constraint.check_if_value_meets_constraint(self, value)\n     66 for evaluator in self._constraint_list:\n---&gt; 67     evaluator(value)\n\nFile ~/development/ASTRA/src/ASTRA/utils/parameter_validators.py:135, in ValueFromDtype._evaluate(self, value)\n    134 msg = f\"Config value ({value}) not from\" f\"the valid dtypes: {type(value)} vs {self.valid_dtypes}\"\n--&gt; 135 raise InvalidConfiguration(\n    136     msg,\n    137 )\n\nInvalidConfiguration: Config value (None) not fromthe valid dtypes: &lt;class 'NoneType'&gt; vs (&lt;class 'bool'&gt;,)\n\nThe above exception was the direct cause of the following exception:\n\nInternalError                             Traceback (most recent call last)\nCell In[10], line 10\n      8 for fluxcorr in [True, False, None]:\n      9     print(\"Update ASTRA config value to\", fluxcorr)\n---&gt; 10     frame.update_user_configs({\"apply_FluxCorr\": fluxcorr})\n\nFile ~/development/ASTRA/src/ASTRA/Components/Modelling.py:156, in Spectral_Modelling.update_user_configs(self, new_configs)\n    154 def update_user_configs(self, new_configs: dict[str, Any]) -&gt; None:\n    155     \"\"\"Propagates update of configs to the interpolation interface.\"\"\"\n--&gt; 156     super().update_user_configs(new_configs)\n    157     self.interpolation_interface.set_interpolation_properties(new_configs)\n\nFile ~/development/ASTRA/src/ASTRA/utils/BASE.py:88, in BASE.update_user_configs(self, new_configs)\n     86 def update_user_configs(self, new_configs: dict[str, Any]) -&gt; None:\n     87     \"\"\"Update the current configurations with new values.\"\"\"\n---&gt; 88     self._internal_configs.update_configs_with_values(new_configs)\n\nFile ~/development/ASTRA/src/ASTRA/utils/UserConfigs.py:192, in InternalParameters.update_configs_with_values(self, user_configs)\n    190 except InvalidConfiguration as exc:\n    191     logger.critical(\"User-given parameter {} does not meet the constraints\", key)\n--&gt; 192     raise InternalError from exc\n    194 self._user_configs[key] = value\n    196 if not self.no_logs:\n\nInternalError: </pre>"},{"location":"user_guide/configuration/#configuration-of-astra-objects","title":"Configuration of ASTRA objects\u00b6","text":""}]}